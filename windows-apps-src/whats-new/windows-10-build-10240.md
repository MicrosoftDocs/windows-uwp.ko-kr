---
author: QuinnRadich
Description: Windows 10 build 10240 and updates to developer tools continue to provide the tools, features, and experiences powered by the Universal Windows Platform.
title: Windows10 빌드 10240-2015 년 7 월의에서 새로운 기능
keywords: 새로운 기능, 새로운 기능, 업데이트, 업데이트, 기능, 신규, Windows 10, 1507, 10240
ms.author: quradic
ms.date: 11/02/2017
ms.topic: article
ms.assetid: 4853e55b-2232-4589-903a-ccb60e07aeb8
ms.localizationpriority: medium
ms.openlocfilehash: c38fe989bd854d44bb7dc3c0cba36a4ae145854c
ms.sourcegitcommit: e814a13978f33654d8e995584f4b047cb53e0aef
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 11/06/2018
ms.locfileid: "6049667"
---
# <a name="whats-new-in-windows10-for-developers-build-10240"></a>개발자를 위한 새로운 Windows10, 빌드 10240

Windows10 빌드 10240 및 업데이트된 SDK는 놀라운 유니버설 Windows 플랫폼 앱을 만드는 도구, 기능 및 환경을 제공합니다. Windows 10에 [도구 및 SDK를 설치](http://go.microsoft.com/fwlink/?LinkId=821431)한 후 [새 유니버설 Windows 앱을 만들](../get-started/create-uwp-apps.md)거나 [Windows에서 기존 앱 코드](../porting/index.md)를 사용하는 방법을 살펴볼 수 있습니다.

Windows10 빌드 10240에에서 있습니다 (Windows 10 버전 1507 라고도 함)에 대 한 새로운 기능 살펴보기 기능으로는 다음과 같습니다.

## <a name="adaptive-layouts"></a>적응형 레이아웃

기능 | 설명
 :---- | ----:
맞춤형 콘텐츠의 여러 보기 | 이제 XAML을 사용하여 동일한 코드 파일을 공유하는 맞춤형 보기(.xaml 파일)를 정의할 수 있습니다. 따라서 특정 장치 패밀리 또는 시나리오에 맞춤화된 다양한 보기를 손쉽게 만들고 유지할 수 있습니다. 앱의 UI 콘텐츠, 레이아웃 또는 탐색 모델이 시나리오마다 크게 다를 경우 여러 보기를 만드세요. 예를 들어, 모바일 앱에서는 한 손 사용에 최적화된 [피벗](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.pivot.aspx)을 사용하고, 데스크톱 앱에서는 마우스에 최적화된 탐색 메뉴가 있는 [SplitView](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.splitview.aspx)를 사용할 수 있습니다.
StateTriggers | 새로운 [VisualState.StateTriggers](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstate.statetriggers.aspx) 기능을 사용하면 창 높이/너비 또는 사용자 지정 트리거를 기준으로 조건에 따라 속성을 설정할 수 있습니다. 이전에는 Window [SizeChanged](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.window.sizechanged.aspx) 이벤트를 코드로 처리하고 [VisualStateManager.GotoState](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstatemanager.gotostate.aspx)를 호출해야 했습니다.
Setter | 새로운 [VisualState.Setters](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstate.setters.aspx) 구문을 사용하면 간단한 태그를 사용하여 [VisualStateManager](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstatemanager.aspx)에서 속성 변경 사항을 정의할 수 있습니다. 예전에는 스토리보드를 사용하고 애니메이션을 만들어서 [StackPanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.stackpanel.aspx)의 방향을 가로에서 세로로 바꾸는 것과 같이 속성을 변경해야 했습니다. 유니버설 Windows 앱에서는 다음과 같이 간단한 Setter 구문을 사용할 수 있습니다. <setter target="stackPanel1.Orientation" value="Vertical" />


## <a name="xaml-features"></a>XAML 기능

기능 | 설명
 :---- | :----
컴파일된 데이터 바인딩(x:Bind) | 유니버설 Windows 앱에서는 x:Bind 속성으로 새로운 컴파일러 기반 바인딩 메커니즘을 사용할 수 있습니다. 컴파일러 기반 바인딩은 컴파일 시 강력한 형식으로 처리되므로 더욱 빠를 뿐만 아니라 바인딩 형식이 일치하지 않을 경우 컴파일 시간 오류를 표시합니다. 또한 바인딩이 컴파일된 앱 코드로 변환되므로 이제 Visual Studio에서 코드를 단계적으로 진행하여 바인딩을 디버깅하고 특정 바인딩 문제를 진단할 수 있습니다. 또한 x:Bind를 사용하여 다음과 같이 메서드로 바인딩할 수 있습니다. <textblock text="{x:Bind Customer.Address.ToString()}" /> 일반적인 바인딩 시나리오에서는 Binding 대신 x:Bind를 사용하여 성능과 유지 관리를 향상할 수 있습니다.
목록의 선언적, 증분적 렌더링(x:Phase) | 유니버설 Windows 앱에서 새로운 x:Phase 특성을 사용하면 코드 대신 XAML을 사용하여 목록의 증분적, 단계적 렌더링을 수행할 수 있습니다. 복잡한 항목이 포함된 긴 목록을 이동할 경우 앱이 이동 속도에 맞추어 항목을 렌더링할 수 없어 사용자 환경이 원활하지 않을 수 있습니다. 단계별 렌더링에서는 목록 항목에서 개별 요소의 렌더링 우선 순위를 지정할 수 있어 빠른 이동 시나리오에서 목록 항목 중 가장 중요한 부분만 렌더링됩니다. 따라서 사용자에게 더 원활한 이동 환경을 제공할 수 있습니다. <br /><br /> Windows 8.1에서는 [ContainerContentChanging](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listviewbase.containercontentchanging.aspx) 이벤트를 처리하고 목록 항목을 단계별로 렌더링하는 코드를 작성할 수 있습니다. UWP 앱의 경우 x:Phase 특성을 사용하여 단계별 렌더링을 선언적으로 완료할 수 있습니다. x:Phase를 컴파일된 바인딩 x:Blind와 함께 사용할 경우 데이터 템플릿의 각 바운드 요소에 대해 렌더링 우선 순위를 쉽게 지정할 수 있습니다. 이동 시 항목 렌더링 작업은 단계를 기준으로 시간 조각으로 나누어지므로 증분적 항목 렌더링이 가능합니다.
UI 요소의 지연된 로드(x:deferLoadstrategy) | 유니버설 Windows 앱에서 새 x:deferLoadstrategy 지시문을 사용하면 로드를 지연할 사용자 인터페이스 부분을 지정하여 시작 성능을 향상하고 앱의 메모리 사용량을 줄일 수 있습니다. 예를 들어 앱 UI에 올바르지 않은 데이터를 입력했을 때에만 표시되는 데이터 유효성 검사 요소가 있는 경우, 필요할 때까지 해당 요소의 로드를 지연할 수 있습니다. 그러면 페이지가 로드될 때 요소 개체가 생성되지 않는 대신 데이터 오류가 있고 페이지의 시각적 트리에 추가되어야 하는 경우에만 생성됩니다.
SplitView | 새로운 [SplitView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.splitview.aspx) 컨트롤을 사용하면 임시 콘텐츠를 손쉽게 표시하거나 숨길 수 있습니다. 이 컨트롤은 일반적으로 탐색 콘텐츠가 숨겨져 있다 사용자 동작으로 필요 시 표시되는 “햄버거 메뉴"와 같은 최상위 탐색 시나리오에 사용됩니다.
RelativePanel | [RelativePanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.relativepanel.aspx)은 서로 또는 부모 패널과 관련하여 자식 개체를 배치하고 정렬할 수 있는 새로운 레이아웃 패널입니다. 예를 들어, 일부 텍스트가 언제나 패널 왼쪽에 표시되고 단추는 항상 텍스트 아래 정렬되도록 지정할 수 있습니다. [StackPanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.stackpanel.aspx) 또는 [Grid](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.grid.aspx)가 필요한 선명한 선형 패턴이 없는 사용자 인터페이스를 만들 때 RelativePanel을 사용합니다.
CalendarView | [CalendarView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.calendarview.aspx) 컨트롤을 사용하면 사용자 지정 월 단위 보기로 날짜와 날짜 범위를 손쉽게 보고 선택할 수 있습니다. CalendarView는 선택 가능한 날짜를 제한할 수 있는 최소, 최대, 블랙아웃 날짜 등의 기능을 지원합니다. 또한 특정 날짜에 일정의 일반적 “예약률"을 표시하는 데 사용할 수 있는 사용자 지정 밀도 막대를 설정할 수 있습니다.
CalendarDatePicker | [CalendarDatePicker](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.calendardatepicker.aspx)는 요일이나 일정의 예약률과 같이 컨텍스트 정보가 중요한 CalendarView에서 단일 날짜를 선택하는 데 최적화된 드롭다운 컨트롤입니다. 이 컨트롤은 [DatePicker](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.datepicker.aspx) 컨트롤과 유사하지만, DatePicker는 생일과 같이 알려진 날짜를 선택하는 데 최적화되었습니다.
MediaTransportControls | 새로운 [MediaTransportControls](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediatransportcontrols.aspx) 클래스를 사용하면 [MediaElement](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaelement.aspx)의 전송 컨트롤을 손쉽게 사용자 지정할 수 있습니다. Windows 8.1에서는 MediaElement의 기본적으로 제공되는 전송 컨트롤을 활성화하거나 MediaElement 메서드를 호출하여 자체 전송 컨트롤을 만들 수 있습니다. 이제 MediaTransportControls의 기본 제공 기능을 사용하면서 앱에 맞게 모양을 쉽게 사용자 지정할 수 있습니다.
속성 변경 알림 | 유니버설 Windows 앱에서는 해당 변경 이벤트가 없는 속성에 대해서도 DependencyObjects에서 속성 변경 사항을 수신 대기할 수 있습니다. 이 알림은 이벤트처럼 작동하지만 실제로는 콜백으로 노출됩니다. 이 콜백은 이벤트 처리기처럼 발신자 인수를 사용하지만 이벤트 인수는 사용하지 않습니다. 대신 어떤 속성인지 나타내기 위해 속성 식별자만 전달됩니다. 이 정보를 사용하여 앱은 여러 속성 알림에 대한 단일 처리기를 정의할 수 있습니다. 자세한 내용은 [RegisterPropertyChangedCallback](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.dependencyobject.registerpropertychangedcallback.aspx) 및 [UnregisterPropertyChangedCallback](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.dependencyobject.unregisterpropertychangedcallback.aspx)을 참조하세요.
지도 | [MapControl](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mapcontrol.aspx) 클래스는 위성 3D 이미지 및 거리 수준 보기를 제공하도록 업데이트되었습니다. 이 새로운 기능 및 이전의 매핑 기능을 이제 유니버설 Windows 앱에서 사용할 수 있습니다. [Windows.UI.Xaml.Controls.Maps](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.aspx) 및 [Windows.Services.Maps](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.aspx) API를 사용하여 앱에 매핑을 추가하세요. 지금 유니버설 Windows 앱에서 이러한 API 사용을 시작하려면 [Bing 지도 개발자 센터](https://www.bingmapsportal.com/)에서 키를 요청하세요. 자세한 내용은 [지도 앱을 인증하는 방법](https://msdn.microsoft.com/library/windows/apps/xaml/dn741528.aspx)을 참조하세요. 또한 Windows 10의 새로운 기능으로, PC 및 휴대폰 사용자는 설정 앱에서 오프라인 지도를 다운로드할 수 있습니다. 사용 가능한 경우 오프라인 지도는 [MapControl](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mapcontrol.aspx)이 인터넷에 액세스할 수 없을 때 지도를 표시하는 데 사용됩니다.
입력 단추 매핑 | [Windows.UI.Xaml.Input.KeyEventArgs](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.input.keyroutedeventargs.aspx) 클래스에는 매핑되지 않은 원래 입력 단추를 키보드 입력 이벤트와 연결할 수 있는 새로운 [OriginalKey](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.input.keyroutedeventargs.originalkey.aspx) 속성이 있으며, [Windows.System.VirtualKey](https://msdn.microsoft.com/library/windows/apps/windows.system.virtualkey.aspx)에 대한 해당 업데이트도 있습니다.
수동 입력 | 이제 [InkCanvas](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.inkcanvas.aspx) 컨트롤 및 기본 [InkPresenter](https://msdn.microsoft.com/library/windows/apps/windows.ui.input.inking.inkpresenter.aspx) 클래스 덕분에 C++, C# 또는 Visual Basic을 사용하여 Windows 런타임 앱의 강력한 수동 입력 기능을 더 간단하게 사용할 수 있습니다. [InkCanvas](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.inkcanvas.aspx) 컨트롤은 잉크 스트로크 그리기 및 렌더링을 위한 오버레이 영역을 정의합니다. 이 컨트롤의 기능(입력, 처리 및 렌더링)은 [InkPresenter](https://msdn.microsoft.com/library/windows/apps/windows.ui.input.inking.inkpresenter.aspx), [InkStroke](https://msdn.microsoft.com/library/windows/apps/windows.ui.input.inking.inkstroke.aspx), [InkRecognizer](https://msdn.microsoft.com/library/windows/apps/windows.ui.input.inking.inkrecognizer.aspx) 및 [InkSynchronizer](https://msdn.microsoft.com/library/windows/apps/windows.ui.input.inking.inksynchronizer.aspx) 클래스에서 제공됩니다. **중요:** 이러한 클래스는 JavaScript를 사용하는 Windows 앱에서는 지원되지 않습니다.


## <a name="updated-xaml-features"></a>업데이트된 XAML 기능

기능 | 설명
 :---- | :----
CommandBar 및 AppBar 업데이트 | [CommandBar](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.commandbar.aspx) 및 [AppBar](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.appbar) 컨트롤이 다양한 장치 패밀리에서 UWP 앱에 대해 일관적 API, 동작, 사용자 환경을 제공하도록 업데이트되었으며, <br /><br />유니버설 Windows 앱의 CommandBar 컨트롤은 AppBar 기능의 상위 집합을 제공하도록 향상되었으며 앱에서 더욱 효율적으로 사용할 수 있게 되었습니다. Windows 10의 모든 신규 유니버설 Windows 앱에 CommandBar를 사용해야 합니다. Windows 8.1의 CommandBar에서는 [AppBarButton](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.appbarbutton.aspx)과 같은 [ICommandBarElement](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.icommandbarelement.aspx)를 구현한 컨트롤만 사용할 수 있습니다. 유니버설 Windows 앱에서는 이제 AppBarButtons뿐만 아니라 CommandBar에 사용자 지정 콘텐츠를 추가할 수 있습니다. <br /><br />AppBar 컨트롤이 업데이트되어 이제 AppBar를 사용하는 Windows 8.1 앱을 유니버설 Windows 플랫폼으로 쉽게 이동할 수 있습니다. AppBar는 전체 화면 앱과 함께 사용하고 에지 제스처를 사용하여 호출하도록 설계되었습니다. 업데이트된 컨트롤 계정에서는 Windows 10에서 창 앱, 에지 제스처 부족 등의 문제가 해결되었습니다. <br /><br />이전에 Windows Phone에만 있었던 [숨겨진 AppBar.ClosedDisplayMode](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.appbar.closeddisplaymode.aspx)가 이제 모든 디바이스 패밀리에서 지원되므로 명령의 다양한 힌트 수준 사이에서 선택할 수 있습니다. AppBar는 Windows 8.1 앱을 플랫폼에서 더 이상 에지 제스처 지원에 의존할 수 없는 유니버설 Windows 앱으로 업그레이드할 때 일관성을 제공하기 위해 기본적으로 최소한의 힌트만 표시합니다.
GridView 업데이트 | Windows 10 이전의 기본 GridView 레이아웃의 방향은 Windows에서 가로, Windows Phone에서 세로였습니다. UWP 앱에서 GridView는 기본적으로 일관적 환경을 보장하기 위해 모든 장치 패밀리에 대해 세로 레이아웃을 사용합니다.
AreStickyGroupHeadersEnabled 속성 | 그룹화된 데이터를 [ListView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listview.aspx) 또는 [GridView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.gridview.aspx)로 표시할 경우 이제 목록을 스크롤할 때 그룹 헤더가 그대로 표시됩니다. 이 기능은 사용자가 헤더를 통해 데이터 컨텍스트를 확인할 수 있는 대규모 데이터 집합에 중요합니다. 하지만, 각 그룹의 요소가 적은 경우에는 헤더가 항목과 함께 화면 밖으로 스크롤되는 것을 원할 수 있습니다. 이 동작을 제어하려면 [ItemsStackPanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.itemsstackpanel.aspx) 및 [ItemsWrapGrid](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.itemswrapgrid.aspx)에서 AreStickyGroupHeadersEnabled 속성을 설정합니다.
GroupHeaderContainerFromItemContainer 메서드 | [ItemsControl](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.itemscontrol.aspx)에서 그룹화된 데이터를 표시할 경우 [GroupHeaderContainerFromItemContainer](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.itemscontrol.groupheadercontainerfromitemcontainer.aspx) 메서드를 호출하여 그룹의 상위 헤더에 대한 참조를 가져올 수 있습니다. 예를 들어, 사용자가 그룹의 마지막 항목을 삭제할 경우 그룹 헤더에 대한 참조를 가져오고 항목과 그룹 헤더를 함께 제거할 수 있습니다.
ChoosingGroupHeaderContainer 이벤트 | [ListViewBase](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listviewbase.aspx)에서 새로운 [ChoosingGroupHeaderContainer](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listviewbase.choosinggroupheadercontainer.aspx) 이벤트를 사용하여 ListView 또는 GridView에서 그룹 헤더에 상태를 설정할 수 있습니다. 예를 들어, 이 이벤트를 처리할 때 그룹 헤더의 [AutomationProperties.Nameproperty](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.automation.automationproperties.nameproperty.aspx)가 보조 기술의 그룹을 나타내도록 설정할 수 있습니다.
ChoosingItemContainer 이벤트 | ListViewBase의 새로운 [ChoosingItemContainer](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listviewbase.choosingitemcontainer.aspx)를 사용하면 [ListView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listview.aspx) 또는 [GridView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.gridview.aspx)에서 UI 가상화를 더 효과적으로 제어할 수 있습니다. 이 이벤트를 [ContainerContentChanging](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listviewbase.containercontentchanging.aspx) 이벤트와 함께 사용하면 재생된 컨테이너의 자체 대기열을 유지하고 필요에 따라 사용할 수 있습니다. 예를 들어, 필터링으로 인해 데이터 원본이 초기화된 경우 이미 생성된 시각적 개체(ItemContainers)에 해당하는 데이터를 빠르게 검색하여 최고의 성능을 달성할 수 있습니다.
목록 스크롤링 가상화 |XAML [ListView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listview.aspx) 및 [GridView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.gridview.aspx) 컨트롤에는 데이터 컬렉션에서 변경이 발생할 때 컨트롤의 성능을 향상시키는 새 [ListViewBase.ChooseingItemContainer](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listviewbase.choosingitemcontainer.aspx) 이벤트가 있습니다. 시스템은 이제 목록을 완전히 다시 설정하여 시작 애니메이션을 재생하는 대신, 포커스 및 선택 상태를 유지하면서 보기에서 항목을 유지합니다. 뷰포트의 새 항목에는 매끄럽게 애니메이션 효과가 나타나고 제거된 항목에서는 애니메이션 효과가 사라집니다. 데이터 컬렉션에서 컨테이너가 소멸되지 않는 변경이 수행되면 앱은 이전 컨테이너에서 "이전" 항목과 일치하는 항목을 빠르게 검색하고 컨테이너 수명 주기 재정의 메서드의 추가 처리를 건너뛸 수 있습니다. "새" 항목만 처리되고 재생된 컨테이너 또는 새 컨테이너와 연결됩니다.
SelectRange 메서드 및 SelectedRanges 속성 | 이제 유니버설 Windows 앱에서 [ListView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listview.aspx) 및 [GridView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.gridview.aspx) 컨트롤을 사용하여 항목 개체 참조가 아닌 항목 색인 범위로 항목을 선택할 수 있습니다. 이 방법에서는 선택한 각 항목에 대해 항목 개체를 만들지 않아도 되므로 항목 선택을 설명하는 더욱 효율적인 방법입니다. 자세한 내용은 [ListViewBase.SelectedRanges](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listviewbase.selectedranges.aspx), [ListViewBase.SelectRange](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listviewbase.selectrange.aspx), [ListViewBase.DeselectRange](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listviewbase.deselectrange.aspx)를 참조하세요.
새 ListViewItemPresenter API | [ListView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listview.aspx) 및 [GridView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.gridview.aspx)는 항목 표시기를 사용하여 선택 및 포커스에 대한 기본 시각적 개체를 제공합니다. UWP 앱의 [ListViewItemPresenter](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.primitives.listviewitempresenter.aspx) 및 [GridViewItemPresenter](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.primitives.gridviewitempresenter.aspx)에는 목록 항목에 대한 화면 표시를 더 자세히 사용자 지정할 수 있는 새로운 속성이 있습니다. 새로운 속성은 CheckBoxBrush, CheckMode, FocusSecondaryBorderBrush, PointerOverForeground, PressedBackground, SelectedPressedBackground입니다.
SemanticZoom 업데이트 | 이제 [SemanticZoom](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.semanticzoom.aspx) 컨트롤이 모든 장치 패밀리에서 UWP 앱에 대해 일관적으로 동작합니다. 확대 보기와 축소 보기 사이를 전환하는 기본 동작은 확대 보기에서 그룹 헤더를 탭하는 것입니다. 이 동작은 Windows Phone 8.1과 동일하지만, 확대 시 축소 제스처를 사용했던 Windows 8.1에서 변경된 것입니다. 축소-확대를 사용하여 보기를 변경하려면 SemanticZoom의 내부 ScrollViewer에서 [ScrollViewer.ZoomMode](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.scrollviewer.zoommode.aspx)="Enabled"로 설정합니다. <br /><br />유니버설 Windows 앱의 경우 확대 보기가 축소 보기로 대체되었으며 대체된 보기와 크기가 동일합니다. 이러한 동작은 Windows 8.1과 동일하지만, 축소 보기가 화면 전체 크기를 차지하고 나머지 콘텐츠 위에 렌더링되었던 Windows Phone 8.1에서 변경된 것입니다.
DatePicker 및 TimePicker 업데이트 | 이제 [DatePicker](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.datepicker.aspx) 및 [TimePicker](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.timepicker.aspx) 컨트롤은 모든 디바이스 패밀리에서 유니버설 Windows 앱에 대해 일관적으로 구현됩니다. 또한 Windows 10에서 새로운 모습으로 표시됩니다. 이제 컨트롤의 팝업 부분이 모든 디바이스에서 [DatePickerFlyout](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.datepickerflyout.aspx) 및 [TimePickerFlyout](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.timepickerflyout.aspx) 컨트롤을 사용합니다. 이 동작은 Windows Phone 8.1과 동일하지만, [ComboBox](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.combobox.aspx)를 사용했던 Windows 8.1에서 변경된 것입니다. 플라이아웃 컨트롤을 사용하면 사용자 지정 날짜와 시간 선택기를 쉽게 만들 수 있습니다.
새로운 ScrollViewer API | [ScrollViewer](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.scrollviewer.aspx)에는 터치식 이동이 시작하거나 중지될 때 앱에 알려주는 새로운 [DirectManipulationStarted](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.scrollviewer.directmanipulationstarted.aspx) 및 [DirectManipulationCompleted](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.scrollviewer.directmanipulationcompleted.aspx) 이벤트가 있습니다. 이러한 이벤트를 처리하여 이러한 사용자 작업에 맞게 UI를 조정할 수 있습니다.
MenuFlyout 업데이트 | 유니버설 Windows 앱에는 더 나은 컨텍스트 메뉴를 더 쉽게 구축할 수 있는 새로운 API가 있습니다. 새로운 [MenuFlyout.ShowAt](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.menuflyout.showat.aspx) 메서드를 사용하면 다른 요소와의 상대적 관계를 기준으로 플라이아웃을 표시할 위치를 지정할 수 있습니다. (MenuFlyout은 앱 창의 경계와 중복될 수도 있습니다.) 계단식 메뉴를 만들려면 새로운 [MenuFlyoutSubItem](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.menuflyoutsubitem.aspx) 클래스를 사용합니다.
ContentPresenter, Grid, StackPanel의 새로운 테두리 속성 | 공통 컨테이너 컨트롤의 새로운 테두리 속성을 사용하면 XAML에 테두리 요소를 추가하지 않고 주위에 테두리를 그릴 수 있습니다. [ContentPresenter](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.contentpresenter.aspx), [Grid](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.grid.aspx), [StackPanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.stackpanel.aspx)에 추가된 새로운 속성은 BorderBrush, BorderThickness, CornerRadius, Padding입니다.
ContentPresenter의 새로운 텍스트 API | [ContentPresenter](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.contentpresenter.aspx)에 텍스트 표시를 더 자세히 제어할 수 있는 새로운 API, LineHeight, LineStackingStrategy, MaxLines, TextWrapping이 있습니다.
시스템 포커스 시각적 상태 | 이제 XAML 컨트롤의 포커스 시각적 상태가 컨트롤 템플릿의 XAML 요소로 선언되지 않고 시스템에 의해 생성됩니다. 모바일 장치에서는 일반적으로 포커스의 시각적 상태가 필요하지 않으며, 시스템에서 이러한 시각적 상태를 만들고 관리하도록 설정할 경우 앱 성능이 향상됩니다. 포커스 시각적 상태를 더 자세히 제어해야 할 경우 시스템 동작을 재정의하고 포커스 시각적 상태를 정의하는 사용자 지정 컨트롤 템플릿을 제공할 수 있습니다. 자세한 내용은 [UseSystemFocusVisuals](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.control.usesystemfocusvisuals.aspx) 및 [IsTemplateFocusTarget](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.control.istemplatefocustargetproperty.aspx)을 참조하세요.
PasswordBox.PasswordRevealMode | 유니버설 Windows 앱에서 [PasswordRevealMode](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.passwordbox.passwordrevealmode.aspx) 속성이 IsPasswordRevealButtonEnabled 속성을 대체하여 디바이스 패밀리 사이에서 일관된 동작을 제공합니다. **주의:** Windows 10 이전에는 기본적으로 암호 표시 단추가 표시되지 않았습니다. 유니버설 Windows 앱에서는 기본적으로 표시됩니다. 앱 보안 정책에 따라 암호를 항상 가려야 하는 경우 PasswordRevealMode를 Hidden으로 설정하세요.
Control.IsTextScaleFactorEnabled | Windows Phone 8.1에서 사용할 수 있었던 [IsTextScaleFactorEnabled](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.control.istextscalefactorenabledproperty.aspx) 속성을 이제 모든 디바이스 패밀리의 유니버설 Windows 앱에서 사용할 수 있습니다.
AutoSuggestBox | Windows Phone 8.1의 [AutoSuggestBox](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.autosuggestbox.aspx) 컨트롤을 이제 모든 디바이스 패밀리의 유니버설 Windows 앱에서 사용할 수 있으며, [SearchBox](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.searchbox.aspx) 대신 사용해야 합니다. AutoSuggestBox는 사용자가 입력하는 대로 제안 단어를 표시하며, 터치, 키보드, 입력기 등의 다양한 입력 유형에서 작동합니다. 또한 검색 상자로 더 효과적으로 작동하는 데 유용한 새 구성 요소, [QueryIcon](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.autosuggestbox.queryicon.aspx) 속성과 [QuerySubmitted](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.autosuggestbox.querysubmitted.aspx) 이벤트가 있습니다.
ContentDialog | Windows Phone 8.1의 [ContentDialog](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.contentdialog.aspx) 컨트롤을 이제 모든 디바이스 패밀리의 유니버설 Windows 앱에서 사용할 수 있습니다. ContentDialog를 사용하면 모든 디바이스에서 원활하게 작동하는 사용자 지정 모달 대화 상자를 표시할 수 있습니다.
Pivot | Windows Phone 8.1의 [Pivot](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.pivot.aspx) 컨트롤을 이제 모든 디바이스 패밀리의 유니버설 Windows 앱에서 사용할 수 있습니다. 이제 모바일 및 데스크톱 디바이스용 앱에서 동일한 Pivot 컨트롤을 사용할 수 있습니다. Pivot은 화면 크기 및 입력 유형을 기준으로 적응 동작을 제공합니다. Pivot 컨트롤을 사용자 지정하면 각 피벗 항목의 정보를 다른 보기로 표시하여 탭과 유사한 동작을 제공할 수 있습니다.

## <a name="text"></a>텍스트

기능 | 설명
 :---- | :----
Windows 코어 텍스트 API | 새 [Windows.UI.Text.Core](https://msdn.microsoft.com/library/windows/apps/windows.ui.text.core.aspx) 네임스페이스는 키보드 입력을 단일 서버에서 처리하는 클라이언트-서버 시스템을 제공합니다. 이 네임스페이스를 사용하여 사용자 지정 텍스트 입력 컨트롤의 편집 버퍼를 조작할 수 있습니다. 텍스트 입력 서버는 앱과 서버 간에 비동기 통신 채널을 통해 텍스트 입력 컨트롤의 내용과 고유한 편집 버퍼의 내용을 항상 동기화 상태로 유지합니다.
벡터 아이콘 | [Glyphs](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.documents.glyphs.aspx) 요소에는 컬러 글꼴을 지원하는 새로운 [IsColorFontEnabled](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.documents.glyphs.iscolorfontenabled.aspx) 및 [ColorFontPalleteIndex](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.documents.glyphs.colorfontpaletteindex.aspx) 속성이 있어 이제 글꼴 파일을 사용하여 글꼴 기반 아이콘을 렌더링할 수 있습니다. 색상표 전환에 ColorFontPalleteIndex를 사용할 경우, 아이콘의 활성화 버전과 비활성화 버전을 표시할 때와 같이 단일 아이콘을 다른 색 집합으로 렌더링할 수 있습니다.
입력기 창 이벤트 | 사용자가 텍스트 입력 상자 바로 아래 창에 표시되는 입력기를 통해 텍스트를 입력하는 경우가 있습니다(일반적으로 동아시아 언어). [TextBox](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.textbox.aspx) 및 [RichEditBox](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.richeditbox.aspx)에서 CandidateWindowBoundsChanged 이벤트 및 DesiredCandidateWindowAlignment 속성을 사용하면 IME 창의 앱 UI를 더 원활히 작동할 수 있습니다.
텍스트 구성 이벤트 | [TextBox](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.textbox.aspx) 및 [RichEditBox](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.richeditbox.aspx)에 입력기를 사용하여 텍스트를 구성할 경우 앱에 알려주는 새 이벤트, TextCompositionStarted, TextCompositionEnded, TextCompositionChanged가 추가되었습니다. 이러한 이벤트를 처리하여 IME 텍스트 구성 프로세스에 맞게 앱 코드를 조정할 수 있습니다. 예를 들어, 동아시아 언어에 인라인 자동 완성 기능을 구현할 수 있습니다.
양방향 텍스트 처리 향상 | XAML 텍스트 컨트롤에 양방향 텍스트 처리를 개선한 새로운 API가 추가되어 다양한 입력 언어에서 텍스트 정렬 및 문단 방향이 향상되었습니다. TextReadingOrder 속성의 기본값이 DetectFromContent로 변경되어 읽는 순서가 기본적으로 감지됩니다. TextReadingOrder 속성도 PasswordBox, RichEditBox, TextBox에 추가되었습니다. 텍스트 컨트롤의 TextAlignment 속성을 새로운 DetectFromContent 값으로 설정하면 콘텐츠 정렬 자동 감지를 사전 설정할 수 있습니다.
텍스트 렌더링 | Windows 10에서 XAML 앱의 텍스트가 거의 모든 상황에서 이제 Windows 8.1 대비 거의 두 배의 속도로 렌더링됩니다. 대부분의 경우 어떤 설정을 변경하지 않고도 앱에서 이와 같이 개선된 성능을 활용할 수 있습니다. 빠른 렌더링 외에도, 이러한 향상을 통해 XAML 앱의 일반적인 메모리 소비가 5% 감소합니다.

## <a name="application-model"></a>응용 프로그램 모델

기능 | 설명
 :---- | :----
Cortana | 외부 응용 프로그램을 시작하고 해당 응용 프로그램 내에서 단일 작업을 실행하는 음성 명령으로 Cortana의 기본 기능을 확장하세요. 앱의 기본 기능을 통합하고 사용자가 앱을 직접 열지 않고도 대부분의 작업을 수행할 수 있는 중앙 진입점을 제공함으로써 Cortana는 앱과 사용자 간의 연락 담당자 역할을 할 수 있습니다. 많은 경우 이 덕분에 사용자는 시간과 노력을 상당히 줄일 수 있습니다. [앱을 Cortana 캔버스에 통합](https://msdn.microsoft.com/library/windows/apps/xaml/dn974230.aspx)하는 방법을 알아보세요. 아이디어가 필요한 경우 [유니버설 Windows 앱에 대한 디자인 기본 사항](https://developer.microsoft.com/windows/design/layout)에서 Cortana와 관련된 디자인 권장 사항 및 UX 지침을 참조할 수 있습니다.
파일 탐색기 | 새 [Windows.System.Launcher.LaunchFolderAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.launcher.launchfolderasync.aspx) 메서드를 사용하면 파일 탐색기를 시작하고 지정한 폴더의 내용을 표시할 수 있습니다.
공유 저장소 | 새 [Windows.ApplicationModel.DataTransfer.SharedStorageAccessManager](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.datatransfer.sharedstorageaccessmanager.aspx) 클래스 및 해당 메서드를 사용하면 URI 활성화를 사용하여 다른 앱을 시작할 때 공유 토큰을 전달하여 다른 앱과 파일을 공유할 수 있습니다. 대상 앱은 원본 앱이 공유하는 파일을 토큰을 지불합니다.
설정 | [LaunchUriAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.launcher.launchuriasync.aspx) 메서드와 ms-settings 프로토콜을 사용하여 기본 제공 설정 페이지를 표시합니다. 예를 들어 다음 코드는 Wi-Fi 설정 페이지를 표시합니다. **bool result = await Launcher.LaunchUriAsync(new Uri("ms-settings://network/wifi"));** <br /><br />표시할 수 있는 설정 페이지 목록에 대해서는 [ms-settings 프로토콜을 사용하여 기본 제공 설정 페이지를 표시하는 방법](https://msdn.microsoft.com/library/windows/apps/jj207014.aspx)을 참조하세요.
앱 간 통신 | Windows 10의 새로운 [앱 간 통신](https://msdn.microsoft.com/library/windows/apps/xaml/dn997827.aspx) API를 통해 Windows 웹 응용 프로그램은 물론 Windows 응용 프로그램 간에 서로 시작하고 데이터 및 파일을 교환할 수 있습니다. 이러한 새 API를 사용하면 이전에는 여러 응용 프로그램을 사용해야 했던 복잡한 작업도 원활하게 처리할 수 있습니다. 예를 들어 앱에서 소셜 네트워킹 앱을 실행하여 연락처를 선택하거나 체크 아웃 응용 프로그램을 실행하여 지급 프로세스를 완료할 수 있습니다.
앱 서비스 | 앱 서비스는 앱이 Windows 10의 다른 앱에 서비스를 제공하는 방법입니다. 앱 서비스는 백그라운드 작업 형식을 취합니다. 포그라운드 앱은 다른 앱의 앱 서비스를 호출하여 백그라운드에서 작업을 수행합니다. 앱 서비스 API에 대한 참조 정보는 [Windows.ApplicationModel.AppService](https://msdn.microsoft.com/library/windows/apps/xaml/windows.applicationmodel.appservice.aspx)를 참조하세요.
앱 패키지 매니페스트 | Windows 10의 [패키지 매니페스트 스키마](https://msdn.microsoft.com/library/windows/apps/br211474.aspx) 참조에 대한 업데이트에는 추가, 제거 및 변경된 요소가 포함됩니다. 스키마의 모든 요소, 특성 및 유형에 대한 참조 정보는 [요소 계층 구조](https://msdn.microsoft.com/library/windows/apps/dn934819.aspx)를 참조하세요.

## <a name="devices"></a>장치

기능 | 설명
 :---- | :----
Microsoft Surface Hub | Microsoft Surface Hub는 Surface Hub 또는 연결된 디바이스에서 기본적으로 실행되는 유니버설 Windows 앱을 위한 강력한 팀 공동 작업 디바이스 및 큰 화면 플랫폼입니다. 큰 화면, 터치 및 수동 입력, 카메라 및 센서 같은 확장 온보드 하드웨어를 활용하는, 비즈니스를 위해 특별히 설계된 고유한 앱을 빌드하세요.<br /><br />[유니버설 Windows 앱에 대한 디자인 기본 사항](https://developer.microsoft.com/windows/design/layout)에서 Surface Hub와 관련된 디자인 권장 사항 및 UX 지침을 살펴보세요. 이러한 문서에서는 유니버설 Windows 앱에 대한 반응형 디자인 기술을 설명합니다. <br /><br />공동 공유 앱 지원에 대한 자세한 내용은 [SharedModeSettings](https://msdn.microsoft.com/library/windows/apps/windows.system.profile.sharedmodesettings.aspx)를 참조하세요. 잉크 입력 및 새 [InkCanvas](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.inkcanvas.aspx) 컨트롤에 대한 다중 지점 잉크 입력 지원에 대한 자세한 내용은 [Windows.UI.Input.Inking](https://msdn.microsoft.com/library/windows/apps/windows.ui.input.inking.aspx) 및 [Windows.UI.Input.Inking.Core](https://msdn.microsoft.com/library/windows/apps/windows.ui.input.inking.core.aspx)를 참조하세요. 센서 입력 처리에 대해서는 [장치, 프린터 및 센서 통합](https://msdn.microsoft.com/library/windows/apps/xaml/br229563.aspx)을 참조하세요.
위치 | Windows 10에서는 사용자의 위치에 대한 액세스 권한을 요청하는 새로운 메서드인 [RequestAccessAsync](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geolocator.requestaccessasync.aspx)를 제공합니다. 사용자는 **설정** 앱의 **위치 개인 정보 설정**에서 자신의 위치 데이터 개인 정보를 설정합니다. 앱은 다음의 경우에만 사용자 위치에 액세스할 수 있습니다. **이 디바이스의 위치**가 켜져 있는 경우 *(휴대폰용 Windows 10은 해당하지 않음)*, 위치 서비스 설정 “**위치**”가 켜짐 상태인 경우 및 **사용자의 위치를 사용할 수 있는 앱 선택**에서 앱이 켜짐 상태로 설정된 경우. <br /><br />사용자의 위치에 액세스하기 전에 **RequestAccessAsync**를 호출하는 것이 중요합니다. 이때 앱이 포그라운드에 있어야 하고 **RequestAccessAsync**이(가) UI 스레드에서 호출되어야 합니다. 사용자가 자신의 위치에 대한 권한을 앱에 부여하기 전에는 앱이 위치 데이터에 액세스할 수 없습니다.
AllJoyn | [Windows.Devices.AllJoyn](https://msdn.microsoft.com/library/windows/apps/windows.devices.alljoyn.aspx) Windows 런타임 네임스페이스는 Microsoft에서 구현한 AllJoyn 오픈 소스 소프트웨어 프레임워크 및 서비스를 제공합니다. 이러한 API를 사용하면 유니버설 Windows 디바이스 앱이 AllJoyn 기반 IoT(사물 인터넷) 시나리오에서 다른 디바이스에 참여할 수 있습니다. AllJoyn C API에 대한 자세한 내용을 보려면 [AllSeen Alliance](https://allseenalliance.org/)에서 설명서를 다운로드하세요. 이 릴리스에 포함된 [AllJoynCodeGen](https://msdn.microsoft.com/library/windows/apps/dn913809.aspx) 도구를 사용하여 디바이스 앱에서 AllJoyn 시나리오를 가능하게 하기 위해 사용할 수 있는 Windows 구성 요소를 생성할 수 있습니다. <br /><br />**참고:** 이제 새 클래스의 소형 디바이스에 Windows 10 IoT Core를 사용할 수 있으므로 Windows 및 Visual Studio를 사용하여 IoT("사물 인터넷") 디바이스를 만들 수 있습니다. [Windows 개발자 센터에서 Windows IoT](https://developer.microsoft.com/windows/iot)에 대해 자세히 알아보세요.
모바일에서 API 인쇄(XAML) | 모바일 장치를 포함한 장치 패밀리의 XAML 기반 UWP 앱에서 인쇄할 수 있는 단일, 통합 API 집합이 있습니다. 이제 Windows.Graphics.Printing 및 Windows.UI.Xaml.Printing 네임스페이스에서 인쇄와 관련된 익숙한 API를 사용하여 모바일 앱으로 인쇄를 추가할 수 있습니다.
배터리 | [Windows.Devices.Power](https://msdn.microsoft.com/library/windows/apps/windows.devices.power.aspx) 네임스페이스의 배터리 API를 사용하면 앱에서 이 앱을 실행 중인 장치에 연결된 모드 배터리에 대해 더 자세히 파악할 수 있습니다. 각각 [FromIdAsync](https://msdn.microsoft.com/library/windows/apps/windows.devices.power.battery.fromidasync.aspx) 또는 [AggregateBattery](https://msdn.microsoft.com/library/windows/apps/windows.devices.power.battery.aggregatebattery.aspx)를 사용해서 [Battery](https://msdn.microsoft.com/library/windows/apps/windows.devices.power.battery.aspx) 개체를 만들어 개별 배터리 컨트롤러 또는 모든 배터리 컨트롤러의 집계를 나타냅니다. [GetReport](https://msdn.microsoft.com/library/windows/apps/windows.devices.power.battery.getreport.aspx) 메서드를 사용하여 해당 배터리의 충전, 용량 및 상태를 나타내는 [BatteryReport](https://msdn.microsoft.com/library/windows/apps/windows.devices.power.batteryreport.aspx) 개체를 반환합니다.
MIDI 장치 | 새 [Windows.Devices.Midi](https://msdn.microsoft.com/library/windows/apps/windows.devices.midi.aspx) 네임스페이스를 사용하면 외부 MIDI 디바이스와 통신할 수 있는 앱, Microsoft GS MIDI 소프트웨어 신시사이저와 직접 통신하는 앱 및 외부 디바이스, 여러 클라이언트가 동시에 단일 MIDI 포트에 액세스하는 시나리오를 만들 수 있습니다.
사용자 지정 센서 지원 | [Windows.Devices.Sensors.Custom](https://msdn.microsoft.com/library/windows/apps/windows.devices.sensors.custom.aspx) 네임스페이스를 사용하여 하드웨어 개발자는 CO2 센서와 같은 새 사용자 지정 센서 형식을 정의할 수 있습니다.
HCE(호스트 기반 카드 에뮬레이션) | 호스트 카드 에뮬레이션을 통해 OS에서 호스트되는 NFC 카드 에뮬레이션 서비스를 구현할 수 있으며 NFC 송수신 장치를 통해 외부 읽기 터미널과 계속 통신할 수 있습니다. NFC를 통해 스마트 카드를 에뮬레이트하는 백그라운드 작업을 트리거하려면 [SmartCardTrigger](https://msdn.microsoft.com/library/windows/apps/xaml/windows.applicationmodel.background.smartcardtrigger.aspx) 클래스를 사용합니다. [SmartCardTriggerType](https://msdn.microsoft.com/library/windows/apps/xaml/windows.devices.smartcards.smartcardtriggertype.aspx) 열거형의 EmulatorHostApplicationActivated 값을 사용하면 앱에서 HCE 이벤트가 발생한 것을 인식할 수 있습니다.

## <a name="graphics"></a>그래픽

기능 | 설명
 :---- | :----
DirectX | Windows 10의 DirectX 12에는 DirectX의 핵심에 해당하는 3D 그래픽 API인 Microsoft Direct3D의 다음 버전이 도입되었습니다. [Direct3D 12 그래픽](https://msdn.microsoft.com/library/windows/desktop/dn903821(v=vs.85).aspx)은 콘솔과 유사한 저급 API의 성능과 효율성을 가능하게 합니다. Direct3D 12는 이전 버전보다 더 빠르고 효율적인 제품입니다. 풍부한 장면, 더 많은 개체, 더 복잡해진 효과, 최신 그래픽 하드웨어를 더욱 잘 사용할 수 있습니다.
SoftwareBitmapSource | 유니버설 Windows 앱에서 XAML 이미지 소스로 새 [SoftwareBitmapSource](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.imaging.softwarebitmapsource.aspx) 형식을 사용할 수 있습니다. 이 경우 인코딩되지 않은 이미지가 XAML 프레임워크로 전달되므로 XAML 프레임워크에서 디코딩한 이미지를 우회하여 화면에 즉시 표시됩니다. 지연 시간이 짧은 사진을 카메라에서 직접 렌더링하거나, 사용자 지정 디코더를 사용하거나, DirectX 표면에서 프레임을 캡처하거나, 메모리 내 이미지를 새로 만들어 짧은 대기 시간 및 낮은 메모리 오버헤드로 XAML에서 직접 렌더링하는 이미지 렌더링 시간을 단축할 수 있습니다.
원근 카메라 | 유니버설 Windows 앱에서 XAML의 새로운 Transform3D API를 사용하여 XAML 트리(또는 장면)에 관점 변환을 적용하면 모든 XAML 하위 요소가 해당 한 가지 장면 전체 변환(또는 카메라)에 따라 변환됩니다. 이전에는 이와 동일한 작업을 수행하기 위해 MatrixTransform과 복잡한 수학을 사용했지만, Transform3D는 이 효과를 매우 간단히 수행하며 애니메이션 효과도 사용할 수 있습니다. 자세한 내용은 [UIElement.Transform3D](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.transform3d.aspx) property, [Transform3D](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.media3d.transform3d.aspx), [CompositeTransform3D](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.media3d.compositetransform3d.aspx), [PerspectiveTransform3D](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.media.media3d.perspectivetransform3d.aspx)를 참조하세요.

## <a name="media"></a>미디어

기능 | 설명
 :---- | :----
HTTP 라이브 스트리밍 | 새 [AdaptiveMediaSource](https://msdn.microsoft.com/library/windows/apps/windows.media.streaming.adaptive.adaptivemediasource.aspx) 클래스를 사용하여 앱에 적응 동영상 스트리밍 기능을 추가할 수 있습니다. 이 개체는 스트리밍 매니페스트 파일을 가리키도록 하여 초기화합니다. 지원되는 매니페스트 형식에는 HLS(Http 라이브 스트리밍) 및 DASH(Dynamic Adaptive Streaming over HTTP)가 포함됩니다. 개체가 XAML 미디어 요소에 바인딩되면 적응 재생이 시작됩니다. 사용 가능, 최소 및 최대 비트 전송률과 같은 스트림의 속성을 쿼리하고 적절한 경우 설정할 수 있습니다.
MFT(Media Foundation Transforms)에 대한 미디어 파운데이션 XVP(Transcode Video Processor) 지원 | MFT(Media Foundation Transforms)를 사용하는 Windows 앱은 이제 **미디어 파운데이션 XVP(Transcode Video Processor)** 를 사용하여 원시 비디오 데이터를 변환하고 크기를 조정하고 변형할 수 있습니다. 새 [MF_XVP_CALLER_ALLOCATES_OUTPUT](https://msdn.microsoft.com/library/windows/desktop/dn803919.aspx) 특성을 사용하면 Microsoft DXVA(DirectX 비디오 가속) 모드에서도 호출자 할당 텍스처로 출력할 수 있습니다. 새 [IMFVideoProcessorControl2](https://msdn.microsoft.com/library/windows/desktop/dn800741.aspx) 인터페이스는 앱에서 하드웨어 효과를 사용하고, 지원되는 하드웨어 효과를 쿼리하고, 비디오 프로세서가 수행하는 회전 작업을 재정의할 수 있도록 합니다.
코드 변환 | 새 [MediaProcessingTrigger](https://msdn.microsoft.com/library/windows/apps/xaml/windows.applicationmodel.background.mediaprocessingtrigger.aspx) API를 통해 앱이 백그라운드 작업에서 미디어 코드 변환을 수행할 수 있으므로 포그라운드 앱이 종료된 경우에도 코드 변환 작업을 계속할 수 있습니다.
MediaElement 미디어 장애 이벤트 | 유니버설 Windows 앱에서는 미디어 콘텐츠에 하나 이상의 유효한 스트리밍이 있을 경우 스트리밍 중 하나에서 디코딩 오류가 발생하더라도 [MediaElement](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.mediaelement.aspx)가 여러 스트리밍이 포함된 콘텐츠를 재생합니다. 예를 들어 오디오 및 동영상 스트림이 포함된 콘텐츠의 동영상 스트림이 실패할 경우 [MediaElement](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.mediaelement.aspx)는 오디오 스트림을 계속 재생합니다. [PartialMediaFailureDetected](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.mediaelement.partialmediafailuredetected.aspx)는 스트림 내의 스트림 중 하나를 디코드할 수 없다고 알려줍니다. 또한 UI에 해당 정보를 반영할 수 있도록 어떤 유형의 스트림이 실패했는지도 알려줍니다. 미디어 스트림 내의 모든 스트림이 실패할 경우 [MediaFailed](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.mediaelement.mediafailed.aspx) 이벤트가 발생합니다.
MediaElement를 이용한 적응형 비디오 스트리밍 지원 | [MediaElement](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.mediaelement.aspx)에는 적응형 비디오 스트리밍을 지원하는 새로운 [SetPlaybackSource](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaelement.setplaybacksource.aspx) 메서드가 있습니다. 이 메서드를 사용하여 미디어 소스를 AdaptiveMediaSource로 설정할 수 있습니다.
MediaElement 및 이미지로 캐스팅 | [MediaElement](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.mediaelement.aspx) 및 이미지 컨트롤에는 새로운 [GetAsCastingSource](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaelement.getascastingsource.aspx) 메서드가 있습니다. 이 메서드를 사용하여 모든 미디어 또는 이미지 요소에서 Miracast, Bluetooth, DLNA와 같은 광범위한 원격 장치로 콘텐츠를 프로그래밍 방식으로 전송할 수 있습니다.MediaElement에서 [AreTransportControlsEnabled](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaelement.aretransportcontrolsenabled.aspx)를 true로 설정하면 이 기능이 자동으로 활성화됩니다.
데스크톱 앱을 위한 미디어 전송 컨트롤 | [ISystemMediaTransportControls](https://msdn.microsoft.com/library/windows/desktop/dn892299(v=vs.85).aspx) 인터페이스 및 관련 API를 통해 데스크톱 앱은 기본 제공 시스템 미디어 전송 컨트롤과 상호 작용합니다. 사용자가 전송 컨트롤 단추를 조작하는 것에 대한 응답, 현재 재생 중인 미디어 콘텐츠에 대한 메타데이터를 표시하도록 전송 컨트롤을 업데이트하는 것 등이 여기에 포함됩니다.
임의 액세스 JPEG 인코딩 및 디코딩 | 새 WIC 메서드 [IWICJpegFrameEncode](https://msdn.microsoft.com/library/windows/desktop/dn903864(v=vs.85).aspx) 및 [IWICJpegFrameDecode](https://msdn.microsoft.com/library/windows/desktop/dn903834(v=vs.85).aspx)를 통해 JPEG 이미지를 인코드 및 디코드할 수 있습니다. 또한 이제 더 큰 메모리 공간을 희생하여 큰 이미지에 대한 효율적인 임의 액세스를 제공하는 이미지 데이터 인덱싱을 사용할 수 있습니다.
미디어 컴퍼지션의 오버레이 | 새 [MediaOverlay](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.editing.mediaoverlay.aspx) 및 [MediaOverlayLayer](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.editing.mediaoverlaylayer.aspx) API를 통해 정적 또는 동적 미디어 콘텐츠의 여러 계층을 쉽게 미디어 컴퍼지션에 추가할 수 있습니다. 각 계층의 불투명도, 위치 및 타이밍을 조정할 수 있으며 입력 계층에 대한 사용자 지정 작성자를 구현할 수도 있습니다.
새로운 효과 프레임워크 | [Windows.Media.Effects](https://msdn.microsoft.com/library/windows/apps/windows.media.effects.aspx) 네임스페이스는 오디오 및 동영상 스트림에 효과를 추가하는 단순하고 직관적인 프레임워크를 제공합니다. 이 프레임워크에는 사용자 지정 오디오 및 동영상 효과를 만들어 미디어 파이프라인에 삽입하도록 구현할 수 있는 기본 인터페이스가 포함되어 있습니다.

## <a name="networking"></a>네트워킹

기능 | 설명
 :---- | :----
소켓 | 소켓 업데이트에는 다음이 포함됩니다. <br /><br />**소켓 브로커:** 소켓 브로커는 앱 수명 주기의 모든 상태에서 앱을 대신하여 소켓 연결을 설정하고 닫을 수 있습니다. 이를 통해 제공되는 앱 및 서비스를 보다 잘 검색할 수 있습니다. 예를 들어 소켓 브로커를 통해 Win32 서비스는 실행되고 있지 않은 경우에도 수신 소켓 연결을 계속 수락할 수 있습니다. <br /><br />**처리량 향상:** 소켓 처리량은 Windows.Networking.Sockets 네임스페이스를 사용하는 앱에 맞게 최적화되었습니다.
백그라운드 전송 처리 후 작업 | [Windows.Networking.BackgroundTransfer](https://msdn.microsoft.com/library/windows/apps/windows.networking.backgroundtransfer.aspx) 네임스페이스의 새 API를 사용하여 처리 후 작업 그룹을 등록할 수 있습니다. 따라서 앱은 포그라운드 상태가 아니더라도 사용자가 다음번에 앱을 다시 시작할 때까지 기다릴 필요 없이 백그라운드 전송의 성공 또는 실패에 대해 즉시 반응할 수 있습니다.
Bluetooth 광고 지원 | [Windows.Devices.Bluetooth.Advertisement](https://msdn.microsoft.com/library/windows/apps/windows.devices.bluetooth.advertisement.aspx) 네임스페이스를 사용하면 앱은 Bluetooth LE 광고를 보내고 받고 필터링할 수 있습니다.
Wi-Fi Direct API 업데이트 | 장치 브로커는 앱을 떠나지 않고도 장치와 연결될 수 있게 업데이트되었습니다. [Windows.Devices.WiFiDirect](https://msdn.microsoft.com/library/windows/apps/windows.devices.wifidirect.aspx) 네임스페이스가 추가되어 해당 장치가 다른 장치에서 검색될 수 있으며 들어오는 연결 알림을 수신할 수 있습니다.<br /><br />**참고:** 이 릴리스에서 향상된 Wi-Fi Direct 기능이 UX에는 제공되지 않으며 누름 단추 페어링만 지원합니다. 또한 이 릴리스에서는 하나만 활성 연결만 지원합니다.
향상된 JSON 지원 | [Windows.Data.Json](https://msdn.microsoft.com/library/windows/apps/windows.data.json.aspx) 네임스페이스는 이제 디버그 세션 중에 JSON 개체를 변환할 때 기존 표준 정의 및 개발자 환경을 더욱 잘 지원합니다.

## <a name="security"></a>보안

기능 | 설명
 :---- | :----
ECC 암호화 | [Windows.Security.Cryptography](https://msdn.microsoft.com/library/windows/apps/windows.security.cryptography.aspx) 네임스페이스의 새 API는 유한체 위의 타원형 곡선을 기반으로 하는 공개 키 암호화 구현을 나타내는 ECC(타원 곡선 암호화)를 지원합니다. ECC는 RSA보다 수학적으로 더 복잡하고, 더 작은 키 크기를 제공하고, 메모리를 적게 소비하고, 성능을 향상시킵니다. 또한 Microsoft 서비스 및 고객에게 RSA 키 및 매개 변수 곡선 NIST 승인 곡선 매개 변수를 대신할 수 있는 기능을 제공합니다.
Microsoft Passport | Microsoft Passport는 암호를 비대칭형 암호화 및 제스처로 바꾸는 대안 인증 방식입니다. [KeyCredentialManger](https://msdn.microsoft.com/library/windows/apps/windows.security.credentials.keycredentialmanager.aspx)와 같은 자격 증명 네임스페이스의 클래스를 통해 개발자는 복잡한 암호화 또는 생체 인식을 사용하지 않고 Microsoft Passport를 사용하여 쉽게 응용 프로그램을 만들 수 있습니다.
Microsoft Passport for Work | Microsoft Passport for Work는 암호, 스마트 카드 및 가상 스마트 카드를 사용하지 않는 Azure Active Directory 계정으로 Windows에 로그인하는 대안 방법입니다. 이 정책 설정을 사용하지 않거나 사용하도록 선택할 수 있습니다.
토큰 브로커 | 토큰 브로커는 앱이 온라인 ID 제공자(예: Facebook)에 쉽게 연결할 수 있도록 하는 새로운 인증 프레임워크입니다. 계정 사용자 이름 및 암호 관리, 간소화된 UI 등의 기능은 사용자에게 획기적으로 개선된 인증 환경을 제공합니다.

## <a name="system-services"></a>시스템 서비스

기능 | 설명
 :---- | :----
전원 | 이제 배터리 절약 모드를 시작하거나 이 모드가 해제될 때 Windows 데스크톱 응용 프로그램에서 알림을 받을 수 있습니다. 응용 프로그램에서 전원 상태 변화에 반응하면서 배터리 수명을 연장할 수 있게 됩니다. <br /><br />[GUID_POWER_SAVING_STATUS](https://msdn.microsoft.com/library/windows/desktop/hh448380.aspx): 배터리 절약 모드를 시작하거나 이 모드가 해제될 때 알림을 받으려면 이 새 GUID와 [PowerSettingRegisterNotification](https://msdn.microsoft.com/library/windows/desktop/hh769082(v=vs.85).aspx) 함수를 함께 사용합니다. <br /><br />[SYSTEM_POWER_STATUS](https://msdn.microsoft.com/library/windows/desktop/aa373232.aspx): 이 구조는 배터리 절약 모드를 지원하도록 업데이트되었습니다. 이제 네 번째 멤버인 *SystemStatusFlag*(이전 이름 Reserved1)는 배터리 절약 모드가 사용되는지 여부를 나타냅니다. [GetSystemPowerStatus](https://msdn.microsoft.com/library/windows/desktop/aa372693(v=vs.85).aspx) 함수를 사용하여 이 구조에 대한 포인터를 가져올 수 있습니다.
버전 | [버전 도우미 함수](https://msdn.microsoft.com/library/windows/desktop/dn424972.aspx)를 사용하여 운영 체제의 버전을 확인할 수 있습니다. Windows 10의 경우 이러한 도우미 함수에는 새로운 함수 [IsWindows10OrGreater](https://msdn.microsoft.com/library/windows/desktop/dn905474(v=vs.85).aspx)가 포함됩니다. 시스템 버전을 확인하려는 경우 더 이상 사용되지 않는 [GetVersionEx](https://msdn.microsoft.com/library/windows/desktop/ms724451.aspx) 및 [GetVersion](https://msdn.microsoft.com/library/windows/desktop/ms724439.aspx)이 아닌 도우미 함수를 사용해야 합니다. 시스템 버전을 가져오는 방법에 대한 자세한 내용은 [시스템 버전 가져오기](https://msdn.microsoft.com/library/windows/desktop/ms724429.aspx)를 참조하세요. <br /><br />더 이상 사용되지 않는 [GetVersionEx](https://msdn.microsoft.com/library/windows/desktop/ms724451.aspx) 또는 [GetVersion](https://msdn.microsoft.com/library/windows/desktop/ms724439.aspx) 함수를 사용하여 [OSVERSIONINFOEX](https://msdn.microsoft.com/library/windows/desktop/ms724833(v=vs.85).aspx) 또는 [OSVERSIONINFO](https://msdn.microsoft.com/library/windows/desktop/ms724834.aspx) 구조의 버전 정보를 가져오는 경우 이러한 구조는 Windows 8.1 및 Windows Server 2012 R2의 6.3에서 Windows 10의 10.0으로 증가한 버전 번호를 포함한다는 점에 유의하시기 바랍니다. 운영 체제 버전 번호에 대한 자세한 내용은 [운영 체제 버전](https://msdn.microsoft.com/library/windows/desktop/ms724832.aspx)을 참조하세요. <br /><br />또한 [GetVersionEx](https://msdn.microsoft.com/library/windows/desktop/ms724451.aspx) 또는 [GetVersion](https://msdn.microsoft.com/library/windows/desktop/ms724439.aspx) 함수를 사용하여 이러한 버전에 대한 올바른 버전 정보를 가져오려면 응용 프로그램에서 Windows 8.1 또는 Windows 10을 구체적으로 대상으로 지정해야 합니다. 이러한 Windows 버전용 응용 프로그램을 대상으로 지정하는 방법에 대한 자세한 내용은 [Windows용 응용 프로그램을 대상으로 지정](https://msdn.microsoft.com/library/windows/desktop/dn481241.aspx)을 참조하세요.
사용자 정보 | [Windows.System](https://msdn.microsoft.com/library/windows/apps/windows.system.aspx) 네임스페이스의 새로운 API를 통해 사용자 이름 및 계정 사진과 같은 사용자 관련 정보에 쉽게 액세스할 수 있습니다. 또한 로그인 및 로그아웃과 같은 사용자 이벤트에 응답하는 기능도 제공합니다.
메모리 관리 및 프로파일링 | [Windows.System](https://msdn.microsoft.com/library/windows/apps/windows.system.aspx)의 메모리 프로파일링 API에 대한 지원이 모든 플랫폼으로 확장되었으며 전반적인 기능이 새로운 클래스 및 함수를 통해 개선되었습니다.

## <a name="storage"></a>저장 장치

기능 | 설명
 :---- | :----
Windows Phone에서 사용할 수 있는 파일 검색 API | 앱 게시자는 앱 매니페스트에 확장을 추가하여 게시하는 다른 앱과 저장소 폴더를 공유하도록 앱을 등록할 수 있습니다. 그런 다음 [Windows.Storage.ApplicationData.GetPublisherCacheFolder](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.getpublishercachefolder.aspx) 메서드를 호출하여 공유 저장소 위치를 가져옵니다. Windows 런타임 앱의 강력한 보안 모델은 일반적으로 앱 간 데이터 공유를 방지합니다. 그러나 동일한 게시자의 앱에서는 사용자별로 파일 및 설정을 공유하는 것이 유용할 수 있습니다.

## <a name="tools"></a>도구

기능 | 설명
 :---- | :----
Visual Studio의 실시간 시각적 트리 | Visual Studio에 새로운 실시간 시각적 트리 기능이 추가되었습니다. 앱의 시각적 트리 상태를 빠르게 이해하기 위해 디버깅하는 동안 이 기능을 사용하여 요소 속성의 설정을 확인할 수 있습니다. 또한 앱이 실행되는 동안 속성 값을 변경할 수 있어 다시 실행하지 않고도 수정과 실험이 가능합니다.
추적 로그 | [TraceLogging](https://msdn.microsoft.com/library/windows/desktop/dn904636(v=vs.85).aspx)은 사용자 모드 앱 및 커널 모드 드라이버에 대한 새 이벤트 추적 API로, [ETW(Windows용 이벤트 추적)](https://msdn.microsoft.com/library/windows/desktop/bb968803(v=vs.85).aspx)를 기반으로 빌드됩니다. 이 API는 별도의 계측 매니페스트 XML 파일 없이도 코드를 계측화하고 이벤트에 구조화된 데이터를 포함하는 간편한 방법을 제공합니다. WinRT,.NET 및 C/C++ TraceLogging API는 각기 다른 개발자 대상 그룹에 사용될 수 있습니다.

## <a name="user-experience"></a>사용자 환경

기능 | 설명
 :---- | :----
음성 인식 | 이제 유니버설 Windows 플랫폼에서는 긴 형식 받아쓰기 시나리오에 대한 지속적인 음성 인식이 지원됩니다. 음성 조작 문서에서 지속적인 받아쓰기를 사용하는 방법을 참조하세요.
다른 응용 프로그램 플랫폼 간 끌어서 놓기 기능 | 새 [Windows.ApplicationModel.DataTransfer.DragDrop](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.datatransfer.dragdrop.aspx) 네임스페이스는 유니버설 Windows 앱에 끌어서 놓기 기능을 제공합니다. 이전과 같이 폴더의 문서를 Outlook 메일 메시지로 끌어와 첨부하는 데스크톱 프로그램의 일반적인 끌어서 놓기 기능이 유니버설 Windows 앱에서는 가능하지 않습니다. 이러한 새로운 API를 사용하여 앱 사용자는 다른 유니버설 Windows 앱과 데스크톱 간에 데이터를 쉽게 이동할 수 있습니다. <br /><br />앱 간 끌어서 놓기 기능을 지원하기 위해 XAML에 다음과 같은 새 API가 추가되었습니다. [ListViewBase.DragItemsCompleted](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listviewbase.dragitemscompleted.aspx); <br />UIElement: [CanDrag](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.candrag.aspx), [DragStarting](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.dragstarting.aspx), [StartDragAsync](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.startdragasync.aspx), [DropCompleted](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.uielement.dropcompleted.aspx);  <br />[DragOperationDeferral](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.dragoperationdeferral.aspx), [DragUI](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.dragui.aspx), [DragUIOverride](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.draguioverride.aspx); <br />DragEventArgs: [AcceptedOperation](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.drageventargs.acceptedoperation.aspx), [DataView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.drageventargs.dataview.aspx), [DragUIOverride](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.drageventargs.draguioverride.aspx), [GetDeferral](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.drageventargs.getdeferral.aspx), [Modifiers](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.drageventargs.modifiers.aspx); <br />[DragItemsCompletedEventArgs](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.dragitemscompletedeventargs.aspx), [DropCompletedEventArgs](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.dropcompletedeventargs.aspx), [DragStartingEventArgs](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.dragstartingeventargs.aspx)
Custom window title bars | 데스크톱 장치 패밀리의 UWP 앱에서 이제 [ApplicationViewTitleBar](https://msdn.microsoft.com/library/windows/apps/windows.ui.viewmanagement.applicationviewtitlebar.aspx) 클래스와 [ApplicationView.TitleBar](https://msdn.microsoft.com/library/windows/apps/windows.ui.viewmanagement.applicationview.titlebar.aspx) 속성 및 [Window.SetTitleBar](https://msdn.microsoft.com/library/windows/apps/windows.ui.viewmanagement.applicationview.titlebar.aspx) 메서드를 사용하여 기본 Windows 제목 표시줄 내용을 사용자 지정 XAML 콘텐츠로 바꿀 수 있습니다. XAML이 “시스템 크롬"으로 취급되므로 Windows는 앱이 아닌 입력 이벤트를 처리합니다. 즉, 사용자가 사용자 지정 제목 표시줄의 내용을 클릭할 때에도 창을 끌어 놓고 크기를 변경할 수 있습니다.

## <a name="web"></a>웹

기능 | 설명
 :---- | :----
Microsoft Edge | Microsoft Edge는 Windows 10용으로 빌드된 새로운 기본 브라우저입니다. 최신 JavaScript 기능을 비롯하여 Microsoft Edge에 포함된 개발자 기능 및 표준에 대한 자세한 내용과 개요는 [Microsoft Edge 개발자 가이드](https://developer.microsoft.com/microsoft-edge/platform/documentation/dev-guide/)를 참조하세요.
WebView 검색 | [WebView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.webview.aspx) 컨트롤은 새로운 Microsoft Edge 브라우저와 동일한 렌더링 엔진을 사용하여 가장 정확한 표준 규격 모드의 HTML 렌더링을 제공합니다.
오프-스레드 WebView | [WebView.ExecutionMode](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.webview.executionmode.aspx)를 지정할 경우 처리를 활성화하고 별도 백그라운드 스레드에 웹 콘텐츠를 표시하여 특정 시나리오에서 성능을 향상할 수 있습니다.
WebView.UnsupportedUriSchemeIdentified 이벤트 | 새로운 [WebView.UnsupportedUriSchemeIdentified](https://msdn.microsoft.com//library/windows/apps/windows.ui.xaml.controls.webview.unsupportedurischemeidentified.aspx) 이벤트를 사용하면 앱에서 지원되지 않는 URI 체계를 처리할 방식을 결정할 수 있습니다. 앱이 지원되지 않는 URI 체계를 처리할 방법을 제공할 수 있도록 이 이벤트를 처리할 수 있습니다. HTML WebView 컨트롤에 대한 자세한 내용은 [MSWebViewUnsupportedUriSchemeIdentified](https://msdn.microsoft.com/library/windows/apps/dn803906.aspx) 이벤트를 참조하세요.
WebView.NewWindowRequested 이벤트 | 새로운 [WebView.NewWindowRequested](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.webview.newwindowrequested.aspx) 이벤트에서는 WebView의 스크립트에서 새 브라우저 창을 요청할 때 응답할 수 있습니다. HTML WebView 컨트롤에 대한 자세한 내용은 [MSWebViewNewWindowRequested](https://msdn.microsoft.com/library/windows/apps/dn803905.aspx) 이벤트를 참조하세요.
WebView.PermissionRequested 이벤트 | 새로운 [WebView.PermissionRequested](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.webview.permissionrequested.aspx) 이벤트에서는 WebView 콘텐츠가 위치와 같이 사용자의 특별 허가가 필요한 새로운 HTML5 API를 활용할 수 있습니다. HTML WebView 컨트롤에 대한 자세한 내용은 [MSWebViewPermissionRequested 이벤트](https://msdn.microsoft.com/library/windows/apps/dn806030.aspx)를 참조하세요.
WebView.UnviewableContentIdentified 이벤트 | 새 [WebView.UnviewableContentIdentified](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.webview.unviewablecontentidentified.aspx) 이벤트에서는 WebView에서 PDF 파일 또는 Office 문서와 같은 웹 이외의 콘텐츠를 탐색할 때 응답할 수 있습니다. HTML WebView 컨트롤에 대한 자세한 내용은 [MSWebViewUnviewableContentIdentified](https://msdn.microsoft.com/library/windows/apps/dn609716.aspx) 이벤트를 참조하세요.
WebView.AddWebAllowedObject 메서드 | 새로운 [WebView.AddWebAllowedObject](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.webview.addweballowedobject.aspx) 메서드를 호출하여 WinRT 개체를 XAML WebView로 불러온 다음 해당 WebView에 호스팅된 신뢰할 수 있는 JavaScript에서 기능을 호출할 수 있습니다. 예를 들어, 웹 콘텐츠가 상위 앱이 [ToastNotificationManager](https://msdn.microsoft.com/library/windows/apps/windows.ui.notifications.toastnotificationmanager.aspx) WinRT API를 호출하도록 요청하여 시스템 알림을 표시할 수 있습니다. HTML WebView 컨트롤에 대한 자세한 내용은 [addWebAllowedObject](https://msdn.microsoft.com/library/windows/apps/dn926632.aspx) 메서드를 참조하세요.
WebView.ClearTemporaryWebDataAsync 메서드 | 사용자가 XAML WebView 내의 웹 콘텐츠와 상호 작용할 경우 WebView 컨트롤은 해당 사용자의 세션을 기준으로 데이터를 캐싱합니다. 새 [ClearTemporaryWebDataAsync](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.webview.cleartemporarywebdataasync.aspx) 메서드를 호출하면 이 캐시를 지울 수 있습니다. 예를 들어 한 사용자가 앱에서 로그아웃할 때 다른 사용자가 이전 세션의 데이터에 액세스할 수 없도록 캐시를 지울 수 있습니다.
