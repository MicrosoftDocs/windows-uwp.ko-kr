---
title: 연결된 저장소 기술 개요
author: aablackm
description: 연결 된 저장소의 내부 작업에서 심층 분석 합니다.
ms.assetid: a0bacf59-120a-4ffc-85e1-fbeec5db1308
ms.author: aablackm
ms.date: 02/27/2018
ms.topic: article
ms.prod: windows
ms.technology: uwp
keywords: xbox live, xbox, 게임, uwp, windows 10, 연결 된 저장소, xbox
ms.localizationpriority: medium
ms.openlocfilehash: c331e85ef5a0012dd038b9b565106ad076333c07
ms.sourcegitcommit: 1c6325aa572868b789fcdd2efc9203f67a83872a
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 10/17/2018
ms.locfileid: "4753190"
---
# <a name="connected-storage"></a>연결된 저장소

> [!NOTE]
> 이 문서의 원래 관리 파트너 Xbox One 개발자 용으로 작성 합니다.  Xbox One 특정 콘텐츠 제목 및 로컬 저장소 같은 일부 Windows의 UWP에 대 한 무시할 수 있습니다.  개념 콘텐츠 및이 문서에서 API 여전히 관련이 있습니다.  모든 질문을 사용 하 여 Microsoft 담당자 (있는 경우)에 문의 하십시오.

저장 된 Xbox 360; 저장 모델을 Xbox One에서 훨씬 다릅니다. Xbox One는 빠른 응용 프로그램 전환에 여러 동시 응용 프로그램을 지 원하는 더 유연한 응용 프로그램 모델 및 빠른 일시 중단 및 다시 시작 앱의. 자동으로 연결 된 저장소 API를 사용 하 여 저장 된 데이터는 여러 Xbox One 콘솔에서 사용자가 로밍 및 오프 라인 사용을 위해 제공 됩니다.

이 항목에 설명 합니다.

-   Xbox One에서 스토어 저장 게임 및 앱 데이터를 연결 된 저장소 API를 사용 합니다.
-   앱의 디자인에 대 한 유용한 Xbox One 응용 프로그램 모델에서 제공 하는 사용자 환경 장점을 잘 통합할 수 있도록 시스템을 저장 합니다.
-   연결 된 저장소 시스템에서 앱 데이터를 저장 하는 데 수 있는 속도 최대화 하는 방법
-   어떻게 시스템 앱 UI를 요구 하지 않고 여러 콘솔에서 동기화 및 데이터 충돌 데이터를 처리 합니다.
-   연결 된 저장소 복원 력 모델은 앱에는 항상 중단 된 네트워크 연결 또는 전원 손실 하는 경우에 개별 컨테이너에 저장 된 데이터의 일관성이 보기에 있도록 설계 되었습니다.

> [!NOTE]
> 용어 *앱*, 여기에서 사용 되는 게임을 포함 하 여 콘솔에서 실행 중인 모든 응용 프로그램을 가리킵니다.

## <a name="overview"></a>개요

Xbox One 응용 프로그램 모델 수 있도록 허용 한 번에 여러 앱을 사용 하 여 사용자가 앱 데이터를 콘솔을 해제 하거나 다른 앱 이동 하기 전에 저장할 때까지 대기 하는 사용자를 요청할 수 없습니다. Xbox One 사용자는 모든 Xbox One 콘솔 자신의 콘솔 느낌이 있도록 콘솔에서 자동으로 로밍 데이터 것 들은 합니다. Xbox One이 플랫폼은 앱이 이러한 요구 사항을 충족 하는 데는 연결 된 저장소 API를 제공 합니다.

연결 된 저장소 시스템을 *컨테이너*에서 하나 이상의 *blob* 으로 데이터를 저장할 수 있습니다. 앱 데이터를 저장 하면 신속 하 게에서 복사 될 단독 파티션을 공유 파티션으로 앱의 수명 외부 디스크의 데이터를 저장 하 고 Xbox Live 타이틀 저장소에 업로드 작업을 처리할 수 있도록 합니다.

연결 된 저장소 시스템에서 특정 사용자의 데이터를 요청 하는 앱을 시스템 자동으로 업데이트 된 데이터에 대 한 클라우드를 사용 하 여 확인 하 고 데이터를 다운로드할 때까지 대기 해야 하는 경우 사용자에 게 알립니다. 시스템에도 사용자가 플레이 때 오프 라인 둘 이상의 콘솔에서 같은 경우에 따라 충돌 데이터 중에서 선택 하는 사용자 요청 또는 다른 콘솔은 업로드 하는 경우 해당 사용자에 대 한 데이터를 저장 합니다.

사용자가 선택을 하드 영구적으로 앱에서 데이터를 삭제 하는 방법에 대 한 다른 앱의 저장 하기 위한 공간을 확보 해야 하지도 앱에 전용 하지만 제한, 모든 사용자에 대 한 클라우드 저장소 공간 양이 있습니다. 하지만 있으면 시스템 로컬 캐시 공간을 확보 하는 것에 대 한 사용자 환경을 제공 하므로 로컬로 저장 캐싱을 위한 Xbox One 하드 드라이브에 저장 공간 제한 된 시간만 합니다. 사용자가 로컬; 캐시의 제어 되지 오프 라인 짓 때 중요 한 데이터에 액세스할 수 없습니다. 연결 된 저장소 시스템에는 소량의 사용자 독립적인 데이터를 앱에 대 한 로컬로 저장 될 수 있습니다. 이 컴퓨터별 데이터는 로밍되지 및 클라우드로 업로드 되지 합니다.

Xbox One 처리할 수 있도록 보류 중인 하드 디스크에 쓰기 및 클라우드로 업로드 자동으로 연결 된 저장소 시스템은 시스템 전원 관리의 관리-있을 필요는 없습니다 UI를 표시 하는 제목에 대 한 "저장 진행 중인 하세요 해제 하지 않는 콘솔." 라고 말합니다.

### <a name="the-xbox-one-app-model-and-app-navigation"></a>Xbox One 앱 모델 및 앱 탐색

Xbox One 통해 사용자를가 여러 응용 프로그램 간에 신속 하 게 전환할 수 있습니다. 잘 작성 된 응용 프로그램은 되었던 곳의 마지막 작업 하는 동안 빠르게 로드 관련 컨텍스트를 사용 하 여 사용자 액세스 마지막 시간 이후 앱 종료 된 경우에 선택할 수 있도록 합니다.

Xbox One 본체 한 번에 독점적 파티션의 하나의 앱을 실행할 수 있습니다. 빠른 전환 사용자 환경을 제공 하려면 단독 현재 실행 중인 앱을 신속 하 게 때 사용자가 다른 실행 종료 해야 합니다. 사용자가 다른 앱으로 전환 하려고 하면 시스템은 활성 앱 일시 중단 알림을 보냅니다. 이 시간 동안 앱 관련 상태를 저장 하 고 해당 Suspend 함수에서 반환 해야 합니다. 시스템에서는이 작업에 대 한 1 초 최대 시간 제한을 적용합니다. 1 초 이내에 앱을 반환 되지 않은, 시스템 응용 프로그램을 강제로 종료 됩니다. 앱, 탐색에서 사용자를 중지할 수 최신 스마트폰 및 태블릿의 탐색 모델와 마찬가지로 합니다.

단독 앱이 일시 중단 시스템의 사용자가 콘솔에서 전원 단추를 누를 때 유휴 상태 이거나 낮은 전원 상태를 입력 하는 등 다른 경우가 있습니다. 앱이 일시 중단 되 면 시스템에 의해 언로드될 없이 다시 시작할 수 있습니다. 이 빠른 다시 시작 기능을 활성화 합니다. 알아야 할 중요 한 점은 하 일시 중단 된 앱도 될 종료 되거나 다시 시작 합니다. 앱이 종료 될 경우 상태를 저장 항상 해야 합니다.

Xbox One 응용 프로그램 모델에서 잘 작동 하려면 앱 직렬화 상태 메모리 버퍼에 신속 하 게 내 관련 상태에 저장 될 수 있도록 준비 해야 1 초 시간 프레임 일시 중단 합니다.

Note 저장 된 데이터에 대 한 사용자 게임 플레이 메뉴 내 위치 등의 앱의 상태에 대 한 데이터는 차이가 있습니다. 앱 일시 중단 되 면 게임 플레이 저장 하는 것 외에도 사용자는 설정을 구성 또는 외부의 주 게임 엔진은 문자를 사용자 지정 하는 경우 메뉴 상태를 유지를 고려해 야 합니다.

사용자는 매우 긴 시간에 대 한 일시 중단 하는 게임을 종료할 수 있습니다. 게임은 다음 긴 일시 중단 다시 시작 되 면 다른 환경을 제공 하는 것이 좋습니다. 1 시간 중단 더 일반적인 되 고 게임 플레이를 수익 보증 반면 2 주에 대 한 사용자가 재생 되지 않은 경우 해당 캠페인에서 한 것이 관건에 사용자를 다시 놓기를 스럽다 고 예기치 않은 환경을 수 있습니다.

Xbox One 앱 모델에 대 한 자세한 내용은 다음 리소스를 참조 하세요.

-   [거실에 대 한 최신 응용 프로그램 전환](https://developer.xboxlive.com/en-us/platform/documentlibrary/events/Documents/Xfest%202012/Xfest%202012%20-%20Modern%20Application%20Switching%20for%20the%20Living%20Room.pptx), Xfest 2012에서 프레젠테이션
-   [The 셸 경험](https://developer.xboxlive.com/_layouts/xna/download.ashx?file=PROD-D_Experience.pptx&folder=platform/xfest2013)을 Xfest 2013에서 프레젠테이션
-   [Xbox One 용 프로세스 수명 관리](https://developer.xboxlive.com/en-us/platform/development/education/Documents/PLM%20for%20Xbox%20One.aspx), GDN에서 백서

> [!NOTE]
> 일부 프레젠테이션 [Xfest 2012](https://developer.xboxlive.com/en-us/platform/documentlibrary/events/Pages/Xfest2012.aspx) 및 [Xfest 2013](https://developer.xboxlive.com/en-us/platform/documentlibrary/events/Pages/Xfest2013.aspx) 에 Xbox One 오프 라인 플레이 지원 발표 인해 오래 된 정보가 있습니다.


### <a name="storage-options-on-xbox-one"></a>Xbox One에서 저장소 옵션

Xbox One는 각각 고유한 장점과 제약 조건을 사용 하 여 여러 저장소 옵션을 제공합니다. 앱을 앱의 요구 사항에 따라 옵션 조합해 서 사용 해야 합니다.


<a name="connected-storage"></a>연결 된 저장소
-----------------

연결 된 저장소는 앱을 Xbox One 게임 플레이 데이터 및 기타 관련 앱 상태-데이터 콘솔 간에 로밍 해야 하는 저장 하도록 설계 되었습니다. 연결 된 저장소 API, Xbox one 특정 저장 하 고 해당 데이터를 업로드 하는 데 도움이 됩니다. API는 Xbox One 응용 프로그램 모델와 함께에서 작동합니다.

연결 된 저장소 API는 다음과 같은 기능을 제공합니다.

-   앱의 시스템에 의해 HDD에 로컬로 캐시 이며을 클라우드에 업로드 하는 시스템 파티션이 메모리 버퍼에 16MB까지 데이터를 한 번에 저장할 신속 하 게 수 있습니다.
- 관리 파트너 및 ID@Xbox 개발자:
  - 256MB 사용자/앱 별 클라우드 저장소입니다.
- Xbox Live 크리에이터 스 프로그램 개발자:
  - 클라우드 저장소의 사용자/앱 별 64 필요 합니다.
-   전원 오류에 대 한 강력한 응답-앱 부분 데이터를 저장 하 고 처리할 필요가 없습니다.
-   앱이 실행 되지 않을 경우에 데이터는 자동으로 클라우드로 업로드 됩니다.
-   Xbox Live에 연결 된 Xbox One 콘솔에서 데이터를 사용할 수 있습니다.
-   Xbox Live가 앱에서 참여 하지 않고도 장치 간 동기화 및 충돌 관리를 처리 합니다.

연결 된 저장소 API에 대 한 자세한 내용은 Xbox Live SDK의 xblesdk.chm (하는 Xbox Live 확장 SDK Api 문서)에 적절 한 섹션을 참조 하세요.


<a name="xbox-live-title-storage"></a>Xbox Live 타이틀 저장소
-----------------------

타이틀 저장소 서비스는 다음과 같은 기능을 사용 하 여 데이터 저장소에 대 한 플랫폼 간 REST API를 제공합니다.

-   사용자, 앱 및 다양 한 플랫폼 간에 공유할 데이터를 제공 합니다.
-   이진 파일을 지 원하는 JSON 및 구성 파일
-   관리 파트너 및 ID@Xbox 개발자:
    - 클라우드 저장소의 사용자/앱 별 256MB
    - 타이틀 글로벌 저장소 당 256MB의
- Xbox Live 크리에이터 스 프로그램 개발자:
  -   클라우드 저장소의 사용자/앱 별 64 MB
  -   타이틀 글로벌 저장소 당 256MB의

서비스를 사용 하기 위한 요구 사항:

-   Xbox One 콘솔 서비스에 액세스 하기 위해 온라인 상태 여야 합니다.
-   앱이 실행 중인; 동안 모든 서비스 조작 완료 해야 합니다. 백그라운드에서 데이터 전송이 자동으로 완료 되지 않습니다.

자세한 내용은 XDK 설명서에서 *Xbox Live 타이틀 저장소*를 참조 하세요.


<a name="local-temporary-storage"></a>로컬 임시 저장소
-----------------------

콘솔에서 앱에 다음과 같은 특성을 사용 하 여 로컬 임시 저장소에 액세스할 수 있습니다.

-   2GB 전용된 하드 드라이브 저장소를 T:\\ 경로에서 액세스할 수 있습니다.
-   앱 실행 중이지 않을 때이 저장소의 콘텐츠를 제거할 수 있습니다.

로컬 저장소에 대 한 자세한 내용은 XDK 설명서의 로컬 저장소를 참조 하세요.


<a name="configuring-your-app-for-connected-storage"></a>연결 된 저장소에 대 한 앱 구성
------------------------------------------

연결 된 저장소 API를 사용 하면 읽기 및 쓰기 작업을 연결 된는 Xbox Live 기본 서비스 구성 ID (서비스 안내), AppXManifest.xml, 앱의 매니페스트 파일에 정의 된 모든:

```xml
      <Extensions>
        <mx:Extension Category="xbox.live">
        <mx:XboxLive TitleId="<your title ID>" PrimaryServiceConfigId="<your SCID>"
        RequireXboxLive="<boolean indicating Live requirement>" />
        </mx:Extension>
      </Extensions>
```

앱에 대 한 제목 ID 및 서비스 안내를 획득 하는 방법에 대 한 자세한 내용은 XDK 설명서에서 *Xbox Live 개발에 대 한 설정을 구성 샌드박스*를 참조 하세요.



## <a name="connected-storage-system-concepts"></a>연결 된 저장소: 시스템 개념

이 섹션에서는 연결 된 저장소 시스템, 관계 및 적절 한 사용의 구성 요소를 설명 합니다.

### <a name="connected-storage-space"></a>연결 된 저장소 공간

높은 수준에서 연결 된 저장소 시스템에서 모든 데이터는 사용자 또는 컴퓨터 (예를 들어, 개별 Xbox One 콘솔)와 연결 합니다. 특정 사용자 또는 컴퓨터에 대 한 앱에서 저장 된 모든 데이터는 연결 된 저장소 공간에 저장 됩니다.

앱의 각 사용자 256MB 총 저장소 한계가 연결 된 저장소 공간을 가져옵니다. 것에 유의 하기 위해 앱만이 저장소 최선을 다하고-다른 앱과 공유 되지 않습니다.

앱은 또한 컴퓨터에 대 한 로컬 연결 된 저장소 공간에서 공간의 64 MB 있습니다. 이 저장소 공간 사용자 별개 이며 사용자가 로그인 하는 경우에 액세스할 수 있습니다.

앱을 연결 된 저장소 공간을 구입, *ConnectedStorageSpace.GetForUserAsync 메서드* 또는 *ConnectedStorageSpace.GetForMachineAsync 메서드*를 호출 합니다. 이 사용자가 한 디바이스에서 데이터를 저장 하 고 게임 플레이 다른 장치에 처음으로 다시 시작 하는 경우에 특히 실행 시간이 긴 작업을 합니다. 이 프로세스와 연결 된 저장소 공간을 확보 하는 앱은 기다리는 동안 발생할 수 있는 가능한 오류 조건에 대 한 자세한 내용은이 문서의 뒷부분에서 *연결 된 저장소 공간 동기화*을 참조 하세요.

앱 **ConnectedStorageSpace** 개체를 획득 하면 *Windows.Storage Namespace* 에서 해당 개체 또는 다른 개체에서 파생을 사용 하는 모든 메서드 호출을 완료 하기 위해 웹 서비스의 응답에 종속 되지 않습니다. 그러나 Xbox One HDD에 대 한 액세스를 활성 앱 단독 없기 때문에 이러한 메서드의 성능에 엄격한 상한은 보장할 수 없습니다.


### <a name="connected-storage-containers-and-blobs"></a>연결 된 저장소: 컨테이너 및 blob

*저장소 컨테이너를 연결*또는 줄여서 *컨테이너* 저장소의 기본 단위입니다. 다음 다이어그램에 표시 된 대로 각 연결 된 저장소 공간에서 여러 컨테이너를 포함할 수 있습니다.

**그림 1.  연결 된 저장소 공간 (제목/컴퓨터 또는 제목/사용자)**

![](../../images/connected_storage/connected_storage_space_containers.png)
데이터는 *blob*을 호출 하는 하나 이상의 버퍼로 컨테이너에 저장 됩니다. 다음 다이어그램은 디스크의 컨테이너의 내부 시스템 표현을 보여 줍니다. 각 컨테이너에 대 한 컨테이너에서 각 blob에 대 한 데이터 파일에 대 한 참조를 포함 하는 컨테이너 파일이 있습니다.

**그림 2.  컨테이너의 다이어그램**

![](../../images/connected_storage/container_storage_blobs.png)

컨테이너에서 데이터를 저장 하기 위해 호출 하 여 *ConnectedStorageContainer.SubmitUpdatesAsync 메서드*이름 및 blob (버퍼 개체)의 지도 제공 합니다. **SubmitUpdatesAsync** 호출에 설명 된 모든 변경 사항이 원자 단위로 적용, 즉, 하거나 요청 하는 모든 blob 업데이트 됩니다 또는 전체 작업이 종료 되 고 컨테이너 호출 하기 전에 상태로 유지 됩니다.

**SubmitUpdatesAsync** 를 사용 하는 개별 저장 작업은 한 번에 데이터의 16MB까지 제한 됩니다.


### <a name="submitupdatesasync-behavior"></a>SubmitUpdatesAsync 동작

**SubmitUpdatesAsync** 호출 되 면 호출에 제공 된 버퍼 빠르게 복사 됩니다 앱 파티션에서 시스템 파티션의 전용된 메모리 공간으로 합니다. 메모리는 성공적으로 시스템 파티션으로 복사 된 후 **SubmitUpdatesAsync** 호출에 제공 된 완료 처리기를 안전한 데이터에 대해 로컬로 할당 된 메모리를 해제 하는 앱을 나타내는 앱 내에서 호출 됩니다.

다음 시스템에서 콘솔의 하드 드라이브에 저장 하 고 해당 컨테이너에서 전체 작업이 커밋합니다 최종 컨테이너 업데이트를 사용 하 여 작업을 완료 합니다.

**SubmitUpdatesAsync** 데이터를 받기 위해 공유 파티션을 메모리에서 16MB 제한이 있습니다. **SubmitUpdatesAsync** 호출 제공할 수 없는 즉시 시스템에 의해 전용된 16MB 버퍼에 충분 한 메모리 없기 때문에, 서비스에 대 한 호출이 대기 됩니다. 시스템 지속적으로 16MB 버퍼에서 데이터를 전송 하는 하드 드라이브 및 대기 중인된 업데이트를 공간 16MB 버퍼에서 사용 가능 해지면 요청 순서 서비스 됩니다.

**그림 3.  SubmitUpdatesAsync 동작**

![](../../images/connected_storage/submitupdatesasync_behavior.png)
유사한 방식으로 발생 하는 클라우드로 업로드: 서비스에 개별 blob을 업로드 하 고 다른 업로드 된 blob을 참조 하는 컨테이너 파일에 최종 업데이트에 의해 업데이트 작업이 커밋될 때 합니다. 클라우드로 업로드, 단일 및 최종 업데이트에이 통합 하면 **SubmitUpdatesAsync** 호출에서 참조 하는 모든 데이터는 전체 하거나 커밋할 또는 컨테이너 남아 변경 되지 않습니다. 이렇게 하면에서 시스템 오프 라인 또는 업로드 작업을 하는 동안 전원이 하는 경우에 사용자가 이동할 수 다른 Xbox One 콘솔에 클라우드에서 데이터를 다운로드 하 고 모든 컨테이너의 일관 된 보기를 사용 하 여 재생을 계속 합니다.

> [!IMPORTANT]
> 컨테이너 간에 데이터 종속성 안전 하지 않습니다.  개별 *SubmitUpdatesAsync* 호출의 결과 완전히 또는 전혀 적용할 보장 됩니다.

**SubmitUpdatesAsync** 호출 해야 향후 **SubmitUpdatesAsync** 호출 컨테이너는 유효한 상태로 유지 하기 위해 성공적으로 완료 될는으로 가정 하지 않아야 합니다. 즉, 앱 컨테이너에 필요한 모든 데이터를 저장 하는 하나 이상의 **SubmitUpdatesAsync** 호출에 사용할 수 없습니다. 나중에 읽을 앱에 대해 유효한 상태가 각 **SubmitUpdatesAsync** 호출에 지정된 된 컨테이너의 내용을 두어야 합니다.

이 문제를 설명 하기 위해 컨테이너 골드 및 Bob 이라는 문자를 소유한 음식 양을 추적 하는 위치는 시나리오를 고려 합니다. 제목 *음식* 및 *골드*라는 두 개의 blob을 저장할 수 있습니다. Bob 자신의 인벤토리에 100 골드 없는 음식으로 시작합니다.

**그림 4.  예제 시나리오: Bob 100 골드로 시작 합니다.**

![](../../images/connected_storage/submitupdatesasync_example_scenario1.png)

이제 Bob 50 골드를 소요 됩니다. 제목 50 골드 blob의 값을 업데이트 **SubmitUpdatesAsync** 통화를 준비 합니다.

시스템은 업데이트 된 blob와 업데이트 버퍼에 컨테이너 업데이트에 대 한 정보를 캡처합니다. 그런 다음 시스템 하드 드라이브에 새 blob의 값을 복사합니다.

**그림 5.  시스템 업데이트 된 정보를 캡처하고 하드 드라이브에 값을 복사 합니다.**

![](../../images/connected_storage/submitupdatesasync_example_scenario2.png)

마지막으로, 새 blob을 참조 하려면 hdd 컨테이너 파일을 업데이트 됩니다. 결국 시스템 가비지 수집 작업에서 참조 되지 않은 blob을 제거합니다.

**그림 6.  시스템 hdd 컨테이너 파일을 업데이트 하 고 참조 되지 않은 blob을 제거 합니다.**

![](../../images/connected_storage/submitupdatesasync_example_scenario3.png)

**SubmitUpdatesAsync** 당 사용 하면 더 많은 blob을 호출 하는 파일 시스템 작업 데이터를 엄격 하 게 저장 하는 데 필요한 원자성 작업을 완료 하는 데 시간이 더 필요 합니다. 위 예제에서 데이터 저장소의 세분성 너무 작은 이지만 명확 하 게 한 컨테이너에서 여러 blob 원자성 업데이트의 동작을 설명 하는 것입니다.


### <a name="updating-multiple-blobs--the-wrong-way"></a>여러 blob 업데이트-잘못 된 방식

Bob 일부 음식 구입 하려는 시나리오를 고려 합니다. 편의 위해 말할 것 주머니 1 개 단위로 음식의 1 개 단위로 구입 하 고 Bob 25 단위의 음식 구입 하려는 합니다. 앱 25 단위의 음식 및 다음 다른 Bob\_Inventory 컨테이너에서 주머니 25 단위를 추가 하는 한 번 **SubmitUpdatesAsync** 호출을 발급할 수 있습니다. 하지만 두 **SubmitUpdatesAsync** 호출 완료 처리기가 호출 된 경우에 하드 드라이브 또는 클라우드는 불완전 한 동기화에 기록의 데이터를 중지 하는 정전 같은 이벤트로 인해 잘못 된 결과 대 한 위험이 있습니다. 다음 다이어그램은 시스템 및 단계 중 하나에 정전의 결과 의해 수행 하는 단계를 설명 합니다.

두 **SubmitUpdatesAsync** 호출의 데이터는 시스템의 업데이트 버퍼에서 이미 모두 호출에 대 한 제목의 완료 처리기가 호출 된 가정 합니다.

먼저 시스템 디스크를 음식 blob의 새 값에 대 한 데이터를 씁니다.

**그림 7.  시스템은 디스크를 음식 blob의 값을 씁니다.**

![](../../images/connected_storage/update_method_wrong_way_1.png)
그런 다음, 새로 쓴된 값을 참조 하는 컨테이너를 업데이트 됩니다. 다음 다이어그램은 에서처럼 뒤,이 단계와 다음 전원 분실 된 경우 Bob 결국에 할인을 사용 하 여 자신의 인벤토리에서 공제 해당 골드 필요 없이 25 음식 느꼈습니다.

**그림 8.  시스템 새로 쓴된 값을 참조 하는 컨테이너를 업데이트 합니다.**

![](../../images/connected_storage/update_method_wrong_way_2.png)

다음으로, 시스템 디스크를 골드 blob의 새 값에 대 한 데이터를 씁니다. 여전히 골드 Bob\_Inventory 컨테이너에서 참조에 대 한 값은 업데이트 되지 않았으면, 되었으며 Bob은 그 보다 더 많은 골드 25-우리가 원하는 결과를 한 번 더 가깝게 하지만 합니다.

**그림 9.  시스템은 디스크를 골드 blob의 새 값에 대 한 데이터를 씁니다.**

![](../../images/connected_storage/update_method_wrong_way_3.png)

시스템 새로 쓴된 blob 골드에 대 한 참조를 컨테이너 파일을 업데이트 하는 마지막으로,-의도 한 결과입니다.

**그림 10.  시스템 새로 쓴된 골드 blob을 참조 하는 컨테이너 파일을 업데이트 합니다.**

![](../../images/connected_storage/update_method_wrong_way_4.png)

### <a name="updating-multiple-blobs--the-right-way"></a>여러 blob 업데이트-적절 한 방법으로

골드 및 Bob의 인벤토리에 음식 양을 업데이트 원자 단위로 정전 인해 잘못 된 중간 상태가 될 가능성이 있는 확인 하는 적절 한 방법은 단일 **SubmitUpdatesAsync** 호출에 모두 blob를 업데이트 하는 것입니다. 시스템은 다음 다음 단계를 수행 합니다.

먼저 시스템 디스크를 음식 blob의 새 값에 대 한 데이터를 씁니다.

**그림 11.  시스템 음식 blob의 새 값에 대 한 데이터를 씁니다.**

![](../../images/connected_storage/update_method_right_way_1.png)
그런 다음 시스템 디스크를 골드 blob의 새 값에 대 한 데이터를 씁니다.

**그림 12.  시스템 골드 blob의 새 값에 대 한 데이터를 씁니다.**

![](../../images/connected_storage/update_method_right_way_2.png)
마지막으로, 시스템에서 새 중 둘 다 참조할 컨테이너 파일을 업데이트 합니다.

**그림 13.  컨테이너 파일 모두 새 blob를 참조 하도록 업데이트 됩니다.**

![](../../images/connected_storage/update_method_right_way_3.png)
이 예제는 매우 간단 하지만 원하는 모든 업데이트가 포함 된 단일 **SubmitUpdatesAsync** 호출을 실행 하 여 자동으로 적용 되어야 하는 컨테이너에서 데이터를 모든 수정의 중요성을 보여 줍니다. 골드를 사용 하 여 음식 구입의 경우이 작업을 수행 하 여 앱 올바르게 값 중 하나에 업데이트 하 고 너무 많은 골드를 사용 하 여 문자를 남길 수 있는 잠재적인 경합 상태를 방지 합니다.

### <a name="performance-characteristics-and-considerations"></a>성능 특성을 고려 사항

공유 파티션의 16MB 업데이트 버퍼 제한 된 개수의 업데이트 작업을 매우 신속 하 게 수행할 수 있습니다. 시스템 데이터 디스크를 유지할 수 있는 속도 모두 버퍼에서 데이터의 양과 blob 수에 따라 다릅니다. 각 blob 버퍼에서 blob 수가 복원 력, 더 큰 디스크에 기록 됩니다, 때문에 시간이 더는 데 걸리는 디스크를 합니다.

그림 13 두 512 k blob 업데이트로 2 초 마다 한 **SubmitUpdatesAsync** 작업에 대해 처리 시간에 대 한 예가 나와 시스템에 다른 하드 드라이브 작업이 없을 때 1024 k blob을 업데이트 합니다. 시스템 14 – 18ms 내에서 각 업데이트를 처리 하는 안정적인 상태에서 작동할 수 있습니다.

**그림 14.  두 512 k blob 업데이트로 2 초 마다 한 SubmitUpdatesAsync 작업에 대해 처리 시간 업데이트 및 다른 하드 드라이브 활동이 없는 1024 k blob.**

![](../../images/connected_storage/submitupdatesasync_proc_time_mixed_size_fixed_interval.png)
그림 14 세 가지 처리 시간을 보여 줍니다. 다양 한 시간 간격 1024 k blob.

시스템은 87ms 안정적인 상태에서 3 초 간격으로 이러한 업데이트를 처리할 수 있습니다. 주파수를 2 초 마다 증가, 시스템 87ms 안정적인 상태 내에서 업데이트를 처리 여전히 수 있습니다.

1 초 업데이트 사이 간격을 줄이고 안정적인 상태 동작을 변경 합니다. 시스템 업데이트, 당 87ms에서 60 업데이트를 처리할 수 있지만 그 외에도 업데이트가 있을 때마다 시간이 오래 걸립니다, 업데이트, 중요 한 변동을 사용 하 여 두 번째 당 500 밀리초 안정적인 상태 처리 시간에 도달 합니다. 16MB 메모리 버퍼 디스크로; 데이터 flush 수 있는 것 보다 더 빠르게 입력할 때문에 이것이 업데이트 이전 업데이트 기록 될 때까지 대기 해야 합니다.

하나의 업데이트 0.5 1 초에 간격을 업데이트할 때 효과 크게 증가 합니다. 시스템은 각 업데이트는 1 초 이상 매우 높은 변형을 사용 하 여 처리할 수 있는 안정 된 상태에 도달 하기 전에 업데이트 당 87ms에이 간격에만 7 업데이트 작업을 다시 처리할 수 있습니다.

**그림 15.  세 가지 처리 시간 1024 k 다양 한 시간 간격 blob.**

![](../../images/connected_storage/submitupdatesasync_proc_time_fixed_size_various_intervals.png)
이들은 메서드와 예제 일 뿐입니다. 앱 일반적으로 하지 않아야 데이터가 저장이 종종 아직 것도 없습니다 일반적으로 작동 중인 I/O 디스크의 무료 환경에서.

이러한 예제에 따라 시스템의 특성을 이해 해야-작동 조건을, 저장 작업 1 초 미만 동안 앱에서에서 완료할 수 있도록 다양 한에서 앱을 측정 하는 처리기 일시 중단의 합니다.


## <a name="synchronizing-a-connected-storage-space"></a>연결 된 저장소 공간을 동기화합니다.

-   연결 확인
-   잠금 취득
-   컨테이너 목록, 비교 및 병합기 논리
-   컨테이너 다운로드

앱 연결 된 저장소 공간에 대 한 액세스를 요청할 경우 시스템에서는 Xbox One 콘솔에서 사용자의 저장 된 데이터는 일관 된 상태로 유지 하 고 자신의 데이터를 오프 라인 재생에 대해 사용할 수 있도록 동기화 프로세스를 수행 합니다. 아니라 때문에 동기화 다양 한 길이의 시간을 수행할 수 있는 사용자 결정을 내리는 데 필요할 수 시스템은 프로세스의 다양 한 단계에서 UI를 사용자에 게 표시할 수 있습니다.

사용자는 동기화 UI 활성화 되는 경우에 언제 든 지 Xbox 단추를 눌러서 앱 외부로 탐색할 수 있습니다. 시스템 UI를 숨겨지고 동기화 사용자 조작 없이 수와 관련해 서 계속 됩니다. 사용자가 다시 앱으로, 동기화가 완료 하지 않는 한 UI 다시 표시 됩니다. 시스템 UI 숨겨져 있을 때 사용자 선택에 대 한 가정 하지 사용 하면 있습니다.

홈 화면에서 사용자가 앱의 렌더링 큰 앱 타일에 표시 되어 경우 동기화가 UI를 표시 하는 시스템, 되므로 앱 **GetForUserAsync** 호출 동안 연관성이 적절 한 시각적 개체를 렌더링 완료 합니다. 계속 해 서 렌더링 앱 여전히 대화형 이며 데이터 로드를 기다리고 사용자에 게 나타냅니다.

다음 다이어그램은 시스템 앱을 연결 된 저장소 공간을 요청 하는 경우 다음 높은 수준의 순서를 설명 합니다. 전체 순서 변수를 사용할 경우 이상 몇 초 동안 시스템에서 그린 동기화 UI 표시 됩니다.

**그림 16.  앱 연결 된 저장소 공간을 요청 하는 경우 시스템에서 다음 순서입니다.**

![](../../images/connected_storage/app_requests_connected_storage_space.png)
시스템은 **GetForUserAsync** 요청을 처리 하는 경우 다음 단계로 이루어집니다.

-   연결 확인
-   잠금 취득
-   컨테이너 목록, 비교 및 병합기 논리
-   컨테이너 다운로드

### <a name="connectivity-check"></a>연결 확인

서비스 **GetForUserAsync** 요청을 시작 하려면 시스템에서는 연결을 확인 합니다. 콘솔 오프 라인 이면 전체 동기화 프로세스는 생략 하 고 지정된 된 사용자에 대 한 연결 된 저장소 공간 현재 세션에 대 한 오프 라인으로 표시 됩니다. 수정 된 모든 데이터 클라우드 저장소를 사용 하 여 조정 된 다음에 동일한 사용자의 연결 된 저장소 공간을 액세스 하는 앱을 시스템 타이틀 저장소 서비스에 도달할 수 있습니다. 이 경우 적이 없는 UI 표시 됩니다.

연결 된 저장소의 컨텍스트 외부에서 오프 라인 처리에 대 한 자세한 내용은 *Xbox One 제목에 대 한 서비스 중단 복원 력*를 참조 하세요.

### <a name="lock-acquisition"></a>잠금 취득

연결을 확인 한 후 시스템 앱 및 현재 사용자와 관련 된 클라우드 저장소 공간에 대 한 단독 액세스 취득 하려고 합니다. 타이틀 저장소의 연결 된 저장 영역에 잠금 파일을 배치 하 여 수행 됩니다. 콘솔 온라인, 서비스에 연결할 수 있고 경우 짧은 기간에 잠글 수, 없는 UI는 제공 되며 동기화 프로세스가 계속 됩니다.

시스템, 특정 연결 된 저장소 공간에 대 한 잠금을 구입 및 앱에 연결 된 저장소 공간의 인스턴스를 반환 되 면 성공적으로 웹 요청에 연결 된 저장소 공간 차단 한다는 내에서 데이터에 작동 none 앱의 API를 호출 합니다. 잠금은 API를 호출 하 여 로컬로 사용할 수 있는 데이터에 따라 작동 사용자가 앱에 연결 된 저장소 공간을 가져온 후 시스템에서 네트워크 케이블을 분리, 경우에 있도록 충분 한 보호를 제공 합니다.

잠금 취득 단계 중 몇 가지 오류 시나리오를 가지 있습니다.

 **UI를 동기화 합니다.** 콘솔 온라인 이지만 잠금 짧은 시간 내에 서비스 로부터 구입한 하지, "동기화" UI가 표시 됩니다.

 **잠금 중단** 사용자가 재생 앱 다른 콘솔에 적는 현재 시나리오에 마지막으로 플레이 이후 것는 다른 콘솔 저장소 공간에 대 한 단독 권한이 되 고 있으며 데이터를 업로드 합니다. 다른 콘솔 데이터 업로드 시작 있지만 마치기 전에 해당 연결 또는 전원 끊어졌습니다는 이기도 합니다.

두이 경우 모두 라고 *잠금 경합*하 고 두 경우에서 시스템은 다른 콘솔은 데이터를 업로드를 설명 하는 UI를 제공 합니다. 사용자는이 프로세스를 완료 하거나 클라우드에 현재 사용 가능한 데이터로 작업할 기다릴 수 있습니다. 시스템에 대 한 잠금을 사용자가 클라우드 데이터를 자체 (하면 잠금이 해제), 사용자 및 앱에 대 한 클라우드 저장소에 대 한 단독 액세스를 획득 합니다. 다른 콘솔에서 업로드 취소 되 고 동기화 프로세스가 계속 됩니다.

### <a name="container-listing-comparison-and-merger-logic"></a>컨테이너 목록, 비교 및 병합기 논리

잠금, 획득 한 후 시스템 클라우드에서 지정 된 앱 및 사용자에 대 한 모든 컨테이너 목록을 요청 합니다. 그런 다음 클라우드에서 데이터를 사용 하 여 로컬 하드 드라이브의 내용을 비교 하 고 비교 결과 따라 진행:

 **로컬 데이터 클라우드 일치** 다른 콘솔에서 변경 된 경우 클라우드 및 로컬 하드 드라이브의 데이터는 동일한, 동기화가 완료, 이때 **GetForUserAsync** 호출 완료 처리기가 호출 하 고 앱 진행할 수 있습니다. 로드 하 고 저장 합니다.

 **로컬 데이터 없음** 클라우드 데이터 이지만 로컬 콘솔 권한이, 있는 경우 클라우드에서 데이터 로컬로 다운로드 됩니다. 이 발생할 수, 예를 들어 친구의 집에서 처음으로 사용자가 플레이 하는 경우.

 **로컬 및 클라우드에서 동일한 컨테이너 수정** 사용자가 다른 콘솔에서 재생 하 여 클라우드에서 컨테이너 쳤을 오프 라인으로 현재 콘솔을 사용 하는 경우 동일한 컨테이너 쳤, 데이터를 자동으로 병합할 수 없습니다. 사용자는 데이터 유지를 선택 해야 합니다. 충돌이 발생 하는 경우 사용자는 대체 정책을 선택할 수 있습니다: 로컬 데이터 또는 클라우드 데이터는 항상 유지, 또는 사용자 선택 **취소** 및 지연 선택할 수 있습니다. 동일한 이름의 컨테이너 대체 정책으로 사용자가 클라우드 또는 로컬 데이터 경우-하지만 다른 콘텐츠를 사용 하 여-적절 하 게 해결 됩니다.

제목 저장에 액세스할 수는 사용자가 **취소**를 선택 하면 시스템 확인 되지 않은 상태를 오프 라인 사용자 재생 중이 던 마치 합니다. 이 경우 충돌 해결 UI 콘솔 온라인 상태인 경우 연결 된 저장소 공간에 대 한 액세스를 요청 하는 앱 다음 번 다시 표시 됩니다.

### <a name="container-download"></a>컨테이너 다운로드

충돌을 해결 된 후 시스템에 클라우드에서 다운로드 해야 하는 컨테이너를 식별 하는 데 필요한 모든 정보. 필요한 모든 컨테이너 다운로드할 수,이 시간에 완료 처리기 *ConnectedStorageSpace.GetForUserAsync 메서드* 호출 될 및 앱 로드 및 저장 진행할 수 있습니다.

이 단계 중 오류가 발생할 수 있습니다.

**부족 하 여 로컬 저장소**  
필수 컨테이너에 대 한 공간 부족 하 여 로컬 하드 드라이브의 경우 사용자가 로컬로 저장 된 데이터를 제거 하 여 디스크 공간을 확보 하 게 UI를 사용 하 여 표시 됩니다. UI을 피할 수 있도록 클라우드에 백업 되지 중요 한 데이터를 영구적으로 삭제, 단순히 로컬 캐시 된 데이터를 및 현재 콘솔에 고유한 데이터를 명확 하 게 나타냅니다.

때 UI는 사용자에 게 제공 됩니다.

-   사용자는 충분 한 공간을 확보, 동기화 계속 하 고 완료 합니다.
-   사용자가 충분 한 공간을 확보 하지 않고 UI를 취소, **GetForUserAsync** 호출 완료 처리기 **OutOfLocalStorage**반환- *ConnectedStorageErrorStatus 열거형*을 참조 하세요. 앱은 사용자가 데이터를 저장할 수는 없지만 재생 하려는 확인 해야 합니다. 사용자가 동의할 경우 해당 사용자에 대 한 데이터를 저장 하지 않고 앱 진행 합니다. 사용자 재생 하는 동안 데이터를 저장 하려는 경우, 앱을 표시 하는 공간 확보를 위해 UI 다음 **GetForUserAsync** 호출을 반복 해야 합니다.

**사용자가 동기화 취소**  
사용자를 완료 하려면 동기화 대기 하지 않을 선택 취소 하는 경우 사용자는 알림을 받습니다 저장 된 데이터의 일부만 제공 됩니다. 이때 **GetForUserAsync** 호출 완료 처리기가 호출 됩니다 및 앱 로드 및 저장 진행할 수 있습니다.

**네트워크 시간 제한**  
데이터 네트워크 연결이 나 서비스 가용성 문제 때문일 제한 시간을 다운로드 하는 경우 사용자는 수 있는 옵션이 동기화 다시 시도 합니다. 자신이 하지 않도록 선택한, 사용자는 알림을 저장 된 데이터의 일부만 제공 됩니다. 이때 **GetForUserAsync** 호출 완료 처리기가 호출 됩니다 및 앱 로드 및 저장 진행할 수 있습니다.

## <a name="development-tools"></a>개발 도구

두 도구 통해 수 있도록 연결 된 저장소의 앱의 사용 개발: XbStorage 및 Fiddler 합니다.

### <a name="managing-connected-storage-with-xbstorage"></a>XbStorage 사용 하 여 연결 된 저장소 관리

XbStorage는 개발 PC에서에서 Xbox One 개발 키트에 연결 된 로컬 저장소 데이터를 관리할 수 있도록 개발 도구입니다.

하드 드라이브에서 연결 된 로컬 저장소 공간을 지우면 뿐 아니라 가져오기 및 XML 파일을 사용 하 여 개별 사용자 또는 컴퓨터-연결 저장소 공간 내보내기 도구를 사용 하면 됩니다.

로컬 연결 된 저장소 공간에는 작업을 수행 시스템 자체 앱에서 해당 작업이 수행 되었는지 처럼 작동 합니다. 복사 하기 전에 클라우드와 동기화를 하면 로컬 파일에 연결 된 저장소 공간에서 데이터를 복사 합니다.

마찬가지로, Xbox One 개발 키트에서 연결 된 저장소 컨테이너에는 개발 PC에 있는 XML 파일에서 데이터를 복사 하면 클라우드 해당 데이터를 업로드 하려면 콘솔. 한 가지 예외가: 개발 키트, 잠금 취득 수 없는 경우 또는 콘솔의 컨테이너와 클라우드에서 간의 충돌이 발생 하는 경우. 이러한 경우에는 콘솔 것 처럼 동작 사용자가 하지 않기로 충돌을 해결-예를 들어 유지 하는 컨테이너의 버전을 선택 하 여-콘솔 처럼 동작 하기 재생 중이 던 오프 라인 제목 시작 될 때까지 합니다.

XbStorage의 초기화 명령은 모든 SCIDs' 및 사용자의 저장 된 데이터의 로컬 저장소를 해제 하지만 클라우드에 저장 된 데이터를 변경 하지 않습니다. 사용자가 콘솔에 로밍 및 제목을 재생 시 클라우드에서 데이터 다운로드 된 경우에 것 상태로 콘솔을 설정 하는 데 유용 합니다.

XbStorage에 대 한 자세한 내용은 XDK 설명서에서 *연결 된 저장소 관리 (xbstorage.exe)를*참조 하세요.

### <a name="monitoring-connected-storage-network-activity-using-fiddler"></a>Fiddler를 사용 하 여 연결 된 저장소 네트워크 활동 모니터링

클라우드 저장소 작업을 수행할 때 콘솔 서비스 상호 작용은 여부를 결정 하는 데 도움이 될 수 있습니다. Fiddler를 사용 하 여 권한 부여 오류를 발생 하는 경우 또는 콘솔 성공적으로 서비스 호출을 수행 하는지 여부를 결정 하는 데 도움이 됩니다. Xbox One에서 Fiddler 설정에 대 한 정보를 *사용 하 여 Xbox One의 Fiddler를 사용 하는 방법*이 XDK 설명서에서 참조 하세요.

## <a name="resources"></a>리소스

위의 리소스 외에도 다음 도움이 될 앱 또는 타이틀 개발에서:

-   XDK 설명서에서 연결 된 저장소 개요
-   [프로세스 수명 관리](https://developer.xboxlive.com/_layouts/xna/download.ashx?file=ProcessLifetimeManagement_08_2013_qfe5.zip&folder=platform/aug2013xdk_qfe5/samples), 샘플에서 게임 개발자 네트워크 (GDN)에서 사용할 수 있는 샘플
-   ["프로세스 수명 관리 (PLM)에 대 한 Xbox One"](https://developer.xboxlive.com/en-us/platform/development/education/Documents/PLM%20for%20Xbox%20One.aspx)GDN에 대 한 백서에서 사용할 수 있는 백서
