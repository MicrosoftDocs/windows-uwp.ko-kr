---
title: 연결된 저장소 기술 개요
description: 연결 된 저장소의 내부 작업에 대 한 고찰 합니다.
ms.assetid: a0bacf59-120a-4ffc-85e1-fbeec5db1308
ms.date: 02/27/2018
ms.topic: article
keywords: xbox live, xbox, 게임, uwp, windows 10, 연결 된 저장소, xbox
ms.localizationpriority: medium
ms.openlocfilehash: 6eddd11a370b8dcadc5108fe00539c2c6d1d9d1a
ms.sourcegitcommit: b034650b684a767274d5d88746faeea373c8e34f
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 03/06/2019
ms.locfileid: "57624058"
---
# <a name="connected-storage"></a>연결된 저장소

> [!NOTE]
> 이 문서는 관리 되는 파트너 Xbox One 개발자를 위한 원래 작성 되었습니다.  Windows에서 UWP에 대 한 로컬 및 제목 저장소와 같은 특정 Xbox One 내용 중 일부를 무시할 수 있습니다.  개념 콘텐츠 및이 문서의 API를 여전히 관련이 있습니다.  질문을 사용 하 여 Microsoft 담당자 (있는 경우)에 문의 하세요.

저장소 및 Xbox One에 모델을 저장 된 Xbox 360; 훨씬 서로 Xbox One 전환, 여러 동시 응용 프로그램에 빠른 응용 프로그램을 지 원하는 더 유연한 응용 프로그램 모델에 빠른 일시 중단 및 앱 다시 시작 합니다. 자동으로 연결 된 저장소 API를 사용 하 여 저장 된 데이터를 여러 Xbox One 콘솔에서 사용자에 대 한 로밍 및 오프 라인 용도로 사용할 수 있습니다.

이 항목에는 다음 내용이 포함됩니다.

-   Xbox One에 저장 하는 스토어 게임 및 앱 데이터에 연결 된 저장소 API를 사용합니다.
-   앱의 디자인에 대 한 모범 사례는 Xbox One 응용 프로그램 모델에서 제공 되는 사용자 환경 이점을 잘 통합 되도록 시스템을 저장 합니다.
-   연결 된 저장소 시스템 앱 데이터를 저장 하는 데 수 있는 속도 최대화 하는 방법
-   어떻게 시스템 앱 UI를 요구 하지 않고 여러 콘솔에서 데이터 동기화 및 데이터 충돌을 처리 합니다.
-   저장소 연결 복원 력 모델은 앱에는 항상 중단된 네트워크 연결 또는 전원 손실 하는 경우에 개별 컨테이너에 저장 된 데이터의 일관성이 보기에 포함 되도록 설계 되었습니다.

> [!NOTE]
> 용어 *앱*사용, 여기에서 게임을 포함 하 여 콘솔에서 실행 중인 모든 응용 프로그램을 가리킵니다.

## <a name="overview"></a>개요

Xbox One 응용 프로그램 모델 즉, 앱 데이터를 저장 하는 콘솔을 해제 하거나 다른 앱으로 이동 하기 전에 대기 하는 사용자를 요청할 수 없습니다를 한 번에 여러 앱을 사용할 수가 있습니다. Xbox One 사용자 모든 Xbox One 콘솔 자체 콘솔 찾기란 있도록 콘솔 간에 자동으로 로밍 하는 데이터 누릴 수도 있습니다. Xbox One 플랫폼에 앱이 이러한 요구 사항을 충족 하는 데 연결 된 저장소 API를 제공 합니다.

연결 된 저장소 시스템에는 앱이 하나 이상의 데이터를 저장 하도록 허용 *blob* 에 *컨테이너*합니다. 데이터를 저장 하는 앱을 신속 하 게 복사 됩니다 전용 파티션에서 공유 파티션으로 앱의 수명 동안 외부 디스크에 데이터를 저장 하 고 Xbox Live 제목 Storage에 업로드 작업을 처리할 수 있도록 합니다.

연결 된 저장소 시스템에서 특정 사용자의 데이터를 요청 하는 앱에 시스템이 자동으로 업데이트 된 데이터에 대 한 클라우드를 사용 하 여 검사 하 고 데이터 다운로드를 대기할 필요가 있는 경우 사용자에 게 알려줍니다. 또한 묻는 메시지가 사용자가 재생 때 오프 라인 둘 이상의 콘솔에서와 같은 일부 경우에서 충돌 하는 데이터 중에서 선택 하는 사용자 또는 다른 콘솔은 업로드 하는 경우 해당 사용자에 대 한 데이터를 저장 합니다.

앱도 있으므로 전용 하지만 제한 된 모든 사용자가 클라우드 저장소 공간을 사용자가 다른 앱의 저장에 대 한 공간을 위해 하나의 앱에서 데이터를 영구적으로 삭제 하는 방법에 대 한 하드 선택을 할 수 없습니다. 가 있지만 시스템 로컬 캐시 공간을 확보 하는 것에 대 한 사용자 환경을 제공 하므로 저장 로컬로 캐싱에 Xbox One 하드 드라이브의 제한 된 양의 저장소 공간. 사용자가 캐시 되는 항목 로컬로;의 제어 이러한 액세스 권한을 잃지 오프 라인 재생 하는 경우에 대 한 처리 되는 데이터입니다. 연결 된 저장소 시스템에는 약간을의 사용자에 관계 없이 데이터를 앱에 대해 로컬로 저장할 수 있습니다. 이 컴퓨터별 데이터 로밍되지 않습니다 및 클라우드에 업로드 되지 않습니다.

Xbox One 처리할 수 있도록 하드 디스크에 쓰기 및 클라우드로 업로드 보류 중 자동으로 연결 된 저장소 시스템의 시스템 전원 관리 담당-"저장 진행에서 하세요. 해제 하지 않는 콘솔입니다."를 UI를 표시 하는 타이틀에 대 한 필요가 없음

### <a name="the-xbox-one-app-model-and-app-navigation"></a>Xbox One 앱 모델 및 앱 탐색

Xbox One에서는 여러 응용 프로그램 사이 빠르게 전환할 수가 있습니다. 잘 작성 된 응용 프로그램에 마지막으로 해당 마지막 작업 시 신속 하 게 로드 하는 관련 컨텍스트를 사용 하 여 앱 사용자가 액세스 된 마지막 시간 이후 종료 된 경우에 선택할 수 있습니다.

Xbox One 콘솔 한 번에 단독 파티션에 하나의 앱을 실행할 수 있습니다. 신속 하 게 사용자 하려고 할 때 다른 실행을 종료 하려면 현재 실행 중인 단독 앱이 필요 빠른 전환을 사용 하는 사용자 환경을 제공 합니다. 사용자가 다른 앱으로 전환 하려고 하면 시스템 활성 앱 일시 중단 알림을 보냅니다. 이 시간 동안 앱 관련 상태를 저장 하 고 해당 Suspend 함수에서 반환 해야 합니다. 시스템에는이 작업에 대 한 1 초의 최대 시간 제한을 적용합니다. 1 초 이내에 앱을 반환 하지 않은 경우 시스템 응용 프로그램을 강제로 종료 합니다. 앱 사용자를 나가면에서 중지할 수 없습니다 처럼 최신 스마트폰 및 태블릿에 탐색 모델.

단독 앱 일시 중단 되는 시스템의 사용자가 콘솔에서 전원 단추를 누를 때을 유휴 또는 낮은 전원 상태를 입력 하는 등 다른 경우가 있습니다. 앱이 중지 되 면 시스템에서 언로드되지 없이 다시 시작할 수 있습니다. 이 빠른 다시 시작 기능을 사용 하도록 설정 합니다. 알아야 할 중요 한 점은 일시 중단 된 앱도 종료 되었거나 다시 시작 합니다. 항상 앱 해야 경우 종료 될 때 상태를 저장 해야 합니다.

Serialize 할 상태를 메모리 버퍼에 신속 하 게 내에서 관련 상태를 저장할 수 있도록 준비 해야 앱 Xbox One 응용 프로그램 모델, 제대로 작동 하는 1 초 시간 프레임을 일시 중단 합니다.

사용자 게임 플레이 대 한 저장 된 데이터 및 메뉴 내에서 위치와 같은 앱의 상태에 대 한 데이터 간의 차이 note 합니다. 앱 일시 중단 되 면 게임 플레이 저장 하는 것 외에도 사용자는 설정을 구성 하거나 기본 게임 엔진 외부에 있는 문자를 사용자 지정 하는 경우 메뉴 상태 유지를 고려해 야 합니다.

사용자가 매우 긴 시간 동안 일시 중단 된 게임을 유지할 수 있습니다. 게임을 오래 일시 중단 이후 다시 시작할 때 다른 환경을 제공 하는 것이 좋습니다. 사용자는 1 시간 동안 중단을 자주 되 고 빠른 게임 플레이 반환을 보증 하는 반면 2 주 동안 재생 되지 않은 경우 해당 캠페인에서 르게에 사용자를 다시 삭제 jarring 및 예기치 않은 경험을 수 있습니다.

Xbox One 응용 프로그램 모델에 대 한 자세한 내용은 다음 리소스를 참조 하세요.

-   [거실에 대 한 최신 응용 프로그램 전환](https://developer.xboxlive.com/en-us/platform/documentlibrary/events/Documents/Xfest%202012/Xfest%202012%20-%20Modern%20Application%20Switching%20for%20the%20Living%20Room.pptx), Xfest 2012에서 프레젠테이션
-   [셸 환경을](https://developer.xboxlive.com/_layouts/xna/download.ashx?file=PROD-D_Experience.pptx&folder=platform/xfest2013), Xfest 2013에서 프레젠테이션
-   [Xbox One에 대 한 프로세스 수명 관리](https://developer.xboxlive.com/en-us/platform/development/education/Documents/PLM%20for%20Xbox%20One.aspx), GDN에서 백서

> [!NOTE]
> 일부 프레젠테이션 [Xfest 2012](https://developer.xboxlive.com/en-us/platform/documentlibrary/events/Pages/Xfest2012.aspx) 하 고 [Xfest 2013](https://developer.xboxlive.com/en-us/platform/documentlibrary/events/Pages/Xfest2013.aspx) Xbox One 오프 라인 재생 지 공지 사항으로 인해 오래 된 정보를 포함 합니다.


### <a name="storage-options-on-xbox-one"></a>Xbox One에 대 한 저장소 옵션

Xbox One는 각각 자체 혜택 및 제약 조건을 사용 하 여 여러 저장소 옵션을 제공합니다. 앱을 앱의 요구 사항에 따라 옵션의 조합을 사용 해야 합니다.


<a name="connected-storage"></a>연결 된 저장소
-----------------
연결 된 저장소는 Xbox One 게임 플레이 데이터 및 기타 관련 앱 상태-데이터를 콘솔 간의 로밍하도록 저장 하는 앱을 위해 설계 되었습니다. Xbox One에 특정 연결 된 저장소 API 저장 하 고 해당 데이터를 업로드를 사용 하 여 지원 합니다. API를 조합 하 여 Xbox One 응용 프로그램 모델을 사용 하 여 작동합니다.

연결 된 저장소 API는 다음과 같은 기능을 제공합니다.

-   앱 다음 hdd 시스템에서 로컬로 캐시 되 고 클라우드로 업로드 하는 시스템 파티션에의 메모리 버퍼에 데이터의 최대 16MB를 한 번에 저장할 신속 하 게 수 있습니다.
- 관리 되는 파트너 및 ID@Xbox 개발자:
  - 클라우드 저장소의 사용자/앱 당 256mb 이상.
- Xbox Live 크리에이터 스 프로그램 개발자:
  - 64MB 사용자/앱 당 클라우드 저장소입니다.
-   전원 오류에 대 한 강력한 응답-앱 저장 되는 일부 데이터와 함께 처리할 필요가 없습니다.
-   앱 실행 중이 아닌 경우에 데이터를 클라우드로 자동으로 업로드 됩니다.
-   Xbox Live에 연결 된 Xbox One 콘솔에서 데이터를 사용할 수 있습니다.
-   Xbox Live 앱 참여를 요구 하지 않고 장치 간 동기화 및 충돌 관리를 처리 합니다.

연결 된 저장소 API에 대 한 자세한 내용은 Xbox Live SDK에서 xblesdk.chm (설명 하는 Xbox Live 확장 SDK Api)에서 적절 한 섹션을 참조 하세요.


<a name="xbox-live-title-storage"></a>Xbox Live 제목 저장소
-----------------------
제목 저장소 서비스는 다음과 같은 기능을 사용 하 여 데이터 저장소에 대 한 크로스 플랫폼 REST API를 제공합니다.

-   사용자, 앱 및 다양 한 플랫폼에서 공유 하는 데이터를 제공 합니다.
-   이진을 지원 하 고 JSON 구성 파일
-   관리 되는 파트너 및 ID@Xbox 개발자:
    - 클라우드 저장소의 사용자/앱 당 256mb 이상
    - 제목 전역 저장소의 256mb 이상
- Xbox Live 크리에이터 스 프로그램 개발자:
  -   클라우드 저장소의 사용자/앱 당 64MB
  -   제목 전역 저장소의 256mb 이상

서비스를 사용 하 여 요구 사항:

-   Xbox One 콘솔 서비스에 액세스 하려면 온라인 상태 여야 합니다.
-   앱을 실행 하는 동안 서비스의 모든 상호 작용을 완료 해야 합니다. 데이터 전송 백그라운드에서 자동으로 완료 되지 않습니다.

자세한 내용은 *Xbox Live 제목 저장소*, XDK 설명서에서.


<a name="local-temporary-storage"></a>로컬 임시 저장소
-----------------------
콘솔에서 앱에 다음 특성을 사용 하 여 로컬 임시 저장소에 액세스할 수 있습니다.

-   T: 경로에서 액세스할 수 있는 전용된 하드 드라이브 저장소의 2GB\\합니다.
-   앱 실행 중이지 않을 때이 저장소의 콘텐츠를 제거할 수 있습니다.

로컬 저장소에 대 한 자세한 내용은 XDK 설명서의 로컬 저장소를 참조 하세요.


<a name="configuring-your-app-for-connected-storage"></a>연결 된 저장소에 대 한 앱 구성
------------------------------------------
연결 된 저장소 API를 사용 하는 경우 모든 읽기 및 쓰기 작업은 연결 사용 하 여는 Xbox Live 기본 서비스 구성 ID (서비스 안내), 앱의 AppXManifest.xml 매니페스트 파일을 정의 합니다.

```xml
      <Extensions>
        <mx:Extension Category="xbox.live">
        <mx:XboxLive TitleId="<your title ID>" PrimaryServiceConfigId="<your SCID>"
        RequireXboxLive="<boolean indicating Live requirement>" />
        </mx:Extension>
      </Extensions>
```

앱에 대 한 제목 ID 및 서비스 안내를 획득 하는 방법에 대 한 자세한 내용은 참조 하세요. *Xbox Live 개발에 대 한 샌드박스를 설정*, XDK 설명서에서.



## <a name="connected-storage-system-concepts"></a>연결 된 저장소: 시스템 개념

이 섹션에서는 연결 된 저장소 시스템, 해당 관계 및 적절 한 용도의 구성 요소를 설명 합니다.

### <a name="connected-storage-space"></a>연결 된 저장소 공간

높은 수준에서 연결 된 저장소 시스템의 모든 데이터는 사용자 또는 컴퓨터 (예를 들어, 개별 Xbox One 콘솔을)를 사용 하 여 연결 합니다. 특정 사용자 또는 컴퓨터에 대 한 앱에서 저장 된 모든 데이터는 연결 된 저장소 공간에 저장 됩니다.

앱의 각 사용자는 최대 256mb의 총 저장소를 사용 하 여 연결 된 저장소 공간을 가져옵니다. 것에 앱에이 저장소는 전용 유의 해야-다른 앱과 공유 되지 않습니다.

앱을 컴퓨터에 대 한 로컬 연결 된 저장소 공간에서 64MB의 공간이 있습니다. 이 저장소 공간은 명의 독립적 이며 사용자가 로그인 하는 경우에 액세스할 수 있습니다.

연결 된 저장소 공간을 호출 하 여 앱을 획득 하는 *ConnectedStorageSpace.GetForUserAsync 메서드* 또는 *ConnectedStorageSpace.GetForMachineAsync 메서드*합니다. 이 사용자 장치 하나에 저장 된 데이터에 다른 장치에서 처음으로 게임 플레이 다시 시작 하는 경우에 특히 잠재적인 장기 실행 작업을 합니다. 이 프로세스와 앱 연결 된 저장소 공간을 획득 하려고 대기 하는 동안 발생할 수 있는 가능한 오류 조건에 대 한 자세한 내용은 참조 하세요 *연결 된 저장소 공간을 동기화*이 문서의 뒷부분에 나오는.

앱에서 획득 한 후는 **ConnectedStorageSpace** 개체에서 모든 메서드를 호출 하는 *Windows.Storage Namespace* 응답에서 파생 된 다른 개체나 개체에 종속 되지 않는 사용 하는 웹 서비스를 완료 합니다. 그러나 Xbox 이상의 HDD에 대 한 액세스를 활성 앱 전용 같지 않으므로 엄격한 상한값 이러한 메서드의 성능 보장할 수 없습니다.


### <a name="connected-storage-containers-and-blobs"></a>연결 된 저장소: 컨테이너 및 blob

합니다 *연결 된 저장소 컨테이너*, 또는 *컨테이너* 줄여서는 저장소의 기본 단위입니다. 다음 다이어그램에 나와 있는 것 처럼 각 연결 된 저장소 공간에서 다양 한 컨테이너를 포함할 수 있습니다.

**그림 1입니다.  연결 된 저장소 공간 (제목 m/컴퓨터 또는 제목/사용자)**

![](../../images/connected_storage/connected_storage_space_containers.png) 데이터는 하나로 컨테이너에 저장 또는 버퍼가 더 호출 *blob*합니다. 다음 다이어그램에서는 디스크에서 컨테이너의 내부 시스템 표현을 보여 줍니다. 각 컨테이너에 대 한 컨테이너의 각 blob에 대 한 데이터 파일에 대 한 참조를 포함 하는 컨테이너 파일이 있습니다.

**그림 2입니다.  컨테이너의 다이어그램**

![](../../images/connected_storage/container_storage_blobs.png)

컨테이너에서 데이터를 저장 하려면 호출을 *ConnectedStorageContainer.SubmitUpdatesAsync 메서드*, 이름 및 blob (버퍼 개체)의 맵을 제공 합니다. 에 설명 된 모든 변경 된 **SubmitUpdatesAsync** 호출 원자적으로 적용 됩니다, 즉, 하거나 모든 blob는 요청에 따라 업데이트 됩니다 또는 전체 작업이 종료 되 고 컨테이너를 호출 하기 전에 상태로 유지 됩니다.

저장 작업을 사용 하는 개별 **SubmitUpdatesAsync** 번 데이터의 16MB로 제한 됩니다.


### <a name="submitupdatesasync-behavior"></a>SubmitUpdatesAsync 동작

때 **SubmitUpdatesAsync** 는 호출 호출에 제공 된 버퍼를 신속 하 게 복사할 앱 파티션에서 시스템 파티션에 전용된 메모리 공간입니다. 완료 처리기에 제공 된 시스템 파티션으로 메모리를 성공적으로 복사 합니다 **SubmitUpdatesAsync** 임을 앱에 안전 하 게 할당 된 메모리를 확보 하는 앱 내에서 호출 됩니다 로컬 데이터용 합니다.

다음 시스템은 콘솔의 하드 드라이브에 blob을 저장 하 고 해당 컨테이너에 대 한 전체 작업을 커밋하는 최종 컨테이너 업데이트를 사용 하 여 작업을 완료 합니다.

16MB 메모리에 수신에 대 한 공유 파티션에 **SubmitUpdatesAsync** 데이터입니다. 호출 하는 경우 **SubmitUpdatesAsync** 즉시 제공할 수 없는 시스템에서 전용된 16MB 버퍼에서 사용 가능한 메모리가 없기 때문에 호출이 큐를 서비스에 대 한 합니다. 시스템 전송 지속적으로 하드 드라이브에 데이터를 16MB 버퍼에서 하 고 큐에 대기 중인된 업데이트 공간이 16MB 버퍼의 사용 가능 해지면 요청한 순서 대로 처리 됩니다.

**그림 3입니다.  SubmitUpdatesAsync 동작**

![](../../images/connected_storage/submitupdatesasync_behavior.png) 클라우드로 업로드 하는 비슷한 방식으로 작업이 수행 됩니다. 개별 blob 서비스에 업로드 되 고 다른 업로드 된 blob을 참조 하는 컨테이너 파일로 최종 업데이트에서 업데이트 작업이 커밋됩니다. 클라우드로 업로드, 단일 및 최종 업데이트를이 통합 되도록 모든 데이터에서 참조 하는 **SubmitUpdatesAsync** 호출은 하거나 전체적으로 커밋되거나 컨테이너 그대로 변경 되지 않습니다. 이러한 방식으로 시스템을 오프 라인 상태가 되거나 업로드 작업 중의 전원이 하는 경우에 사용자 없습니다 이동 다른 Xbox One 콘솔로 클라우드에서 데이터를 다운로드 하 고 모든 컨테이너의 일관 된 뷰를 사용 하 여 재생을 계속 합니다.

> [!IMPORTANT]
> 컨테이너에서 종속성 데이터는 안전 하지 않습니다.  개별 결과 *SubmitUpdatesAsync* 완전히 나타나거나 전혀 나타나지 적용할 호출이 보장 됩니다.

**SubmitUpdatesAsync** 호출 해야 하는 가정 하지 이후 **SubmitUpdatesAsync** 컨테이너를 유효한 상태로 유지 하기 위해 호출을 성공적으로 완료할 수 됩니다. 즉, 앱은 사용할 수 없습니다 둘 이상의 **SubmitUpdatesAsync** 컨테이너에 필요한 모든 데이터를 저장 하려면 호출 합니다. 각 **SubmitUpdatesAsync** 호출 지정된 된 컨테이너의 내용을 나중에 읽을 앱에 대 한 유효한 상태로 유지 해야 합니다.

이 문제를 보여 주기 위해 컨테이너 골드 및 Bob 이라는 문자를 소유 하는 음식 양을 추적 하는 위치는 시나리오를 살펴보겠습니다. 제목 라는 두 개의 blob을 저장할 수 있습니다 *음식* 하 고 *골드*합니다. Bob은 자신의 인벤토리에 100 골드 없습니다 음식으로 시작합니다.

**그림 4와 같습니다.  예제 시나리오: Bob은 금 100을 시작합니다.**

![](../../images/connected_storage/submitupdatesasync_example_scenario1.png)

이제 Bob 50g을 소비 합니다. 제목 준비를 **SubmitUpdatesAsync** 골드 blob의 값을 50 업데이트를 호출 합니다.

시스템은 업데이트 버퍼에 대 한 컨테이너 업데이트에 대 한 정보와 업데이트 된 blob를 모두 캡처합니다. 그런 다음 시스템 하드 드라이브에 새 blob의 값을 복사합니다.

**그림 5입니다.  시스템은 업데이트 된 정보를 캡처하고 하드 드라이브에 값을 복사 합니다.**

![](../../images/connected_storage/submitupdatesasync_example_scenario2.png)

마지막으로, 새 blob을 참조 하는 HDD에 컨테이너 파일을 업데이트 됩니다. 결국 시스템의 가비지 수집 작업에서 참조 되지 않은 blob를 제거합니다.

**그림 6입니다.  시스템 hdd 컨테이너 파일을 업데이트 하 고 참조 되지 않은 blob를 제거 합니다.**

![](../../images/connected_storage/submitupdatesasync_example_scenario3.png)

사용 하는 더 이상 blob 당 참고 **SubmitUpdatesAsync** 호출 시간이 더 안정적으로 데이터를 저장할 파일 시스템 작업의 필요한 원자성 작업을 완료 하는 데 필요한 됩니다. 앞의 예제에서 데이터 저장소의 세분성 너무 크지 않지만 명확 하 게 하나의 컨테이너에서 여러 blob의 원자성 업데이트의 동작을 설명 하기 위한 것입니다.


### <a name="updating-multiple-blobs--the-wrong-way"></a>여러 blob를 업데이트 하는 중-잘못 된 방식

Bob 일부 음식 구입 하려는 경우를 고려해 보십시오. 간단히 하기 위해 1 개 단위의 골드 food 1 단위를 구입 하 고 Bob 25 단위의 음식 구입 하려는 라고 합니다. 응용 프로그램 하나를 실행할 수 **SubmitUpdatesAsync** 25 단위의 골드 임대가에서 뺄 25 단위의 식품 및 다른 하나를 추가 하는 호출이\_인벤토리 컨테이너입니다. 경우에 있지만 둘 다에 대 한 완료 처리기 **SubmitUpdatesAsync** 호출 호출 되 면 데이터 하드 드라이브에 기록 되지 않을 수 있습니다는 정전과 같은 이벤트로 인해 잘못 된 결과 대 한 가능성이 또는 클라우드로 동기화 완전 하지 않습니다. 다음 다이어그램에서는 시스템 및 단계 중 하나에서 전원 손실의 결과 수행한 단계를 설명 합니다.

가정 데이터는 모두 **SubmitUpdatesAsync** 호출 시스템의 업데이트 버퍼 이미 있고 두 호출에 대 한 해당 타이틀의 완료 처리기가 호출 된 합니다.

먼저 시스템 음식 blob의 새 값에 대 한 데이터를 디스크에 씁니다.

**그림 7입니다.  시스템은 디스크에 음식 blob의 값을 씁니다.**

![](../../images/connected_storage/update_method_wrong_way_1.png) 그런 다음 컨테이너에서 새로 작성된 된 값을 참조할 수 업데이트 됩니다. 다음 다이어그램 에서처럼 다음 전과이 단계를 수행한 후 전원 손실 된 경우 bob은 결국 상당수를 사용 하 여 자신의 인벤토리에서 차감 해당 골드 필요 없이 25 식품을 얻을 수 없습니다.

**그림 8입니다.  시스템 새로 작성된 된 값을 참조 하는 컨테이너를 업데이트 합니다.**

![](../../images/connected_storage/update_method_wrong_way_2.png)

다음으로, 시스템 디스크에 골드 blob의 새 값에 대 한 데이터를 씁니다. 골드 임대가에서 참조 값\_여전히 인벤토리 컨테이너는 업데이트 되지 않은, 있고 Bob은 그 보다 자세한 골드 25-원하는 결과 한 단계 더 가까워졌습니다 하 고 있지만 해당 합니다.

**그림 9입니다.  시스템은 디스크에 골드 blob의 새 값에 대 한 데이터를 씁니다.**

![](../../images/connected_storage/update_method_wrong_way_3.png)

시스템에서 gold 새로 작성된 된 blob 참조를 컨테이너 파일을 업데이트 하는 마지막으로,-의도 한 결과입니다.

**그림 10입니다.  시스템은 컨테이너 파일을 새로 작성된 된 골드 blob 참조를 업데이트 합니다.**

![](../../images/connected_storage/update_method_wrong_way_4.png)

### <a name="updating-multiple-blobs--the-right-way"></a>여러 blob를 업데이트 하는 중-올바른 방법으로

골드 및 음식 Bob의 재고 양을 원자적으로 업데이트 되 면 들어 전력 손실로 인해 잘못 된 중간 상태의 가능성 없이 확인 하는 적절 한 방법은 단일 blob을 모두 업데이트 하는 것 **SubmitUpdatesAsync** 호출 합니다. 시스템 다음 단계 수행 됩니다.

먼저 시스템 음식 blob의 새 값에 대 한 데이터를 디스크에 씁니다.

**그림 11입니다.  시스템 음식 blob의 새 값에 대 한 데이터를 씁니다.**

![](../../images/connected_storage/update_method_right_way_1.png) 그런 다음 시스템 디스크에 골드 blob의 새 값에 대 한 데이터를 씁니다.

**그림 12입니다.  시스템 골드 blob의 새 값에 대 한 데이터를 씁니다.**

![](../../images/connected_storage/update_method_right_way_2.png) 마지막으로, 시스템 컨테이너 파일을 모두 새 blob 참조를 업데이트 합니다.

**그림 13입니다.  시스템은 컨테이너 파일을 모두 새 blob 참조를 업데이트 합니다.**

![](../../images/connected_storage/update_method_right_way_3.png) 단일을 실행 하 여 원자 단위로 적용 되어야 하는 컨테이너의 모든 데이터 수정 과정의 중요성을 보여 줍니다이 예제에서는 매우 간단한 상태인 **SubmitUpdatesAsync** 원하는 모든 업데이트를 사용 하 여 호출 합니다. 골드를 사용 하 여 음식 구입의 경우 이렇게 하면 앱에 올바르게 하나의 값을 업데이트 하 고 너무 많은 골드를 사용 하 여 문자를 그대로 있는 잠재적인 경합 조건을 방지할 수 있습니다.

### <a name="performance-characteristics-and-considerations"></a>성능 특성 및 고려 사항

공유 파티션에 16MB 업데이트 버퍼에는 제한 된 수를의 업데이트 작업을 매우 신속 하 게 수행할 수 있습니다. 속도는 시스템 디스크에 데이터를 유지할 수 버퍼에 데이터의 양이 두 blob의 수에 따라 달라 집니다. 각 blob은 버퍼에서 blob의 수를 더 큰 복원 력을 사용 하 여 디스크에 기록 하기 때문에 시간이 더 걸리는 디스크에 유지 하도록 합니다.

그림 13에 대 한 처리 시간에 대 한 예를 보여 줍니다.는 **SubmitUpdatesAsync** 하나 및 두 512k blob 업데이트를 사용 하 여 2 초 마다 작업 시스템에서 다른 하드 드라이브 활동이 없는 경우 1024 k blob를 업데이트 합니다. 시스템에서 14-18ms 내 각 업데이트를 처리 하는 안정적인 상태에서 작동할 수 있습니다.

**그림 14입니다.  두 512k blob 업데이트를 사용 하 여 2 초 마다 개와 SubmitUpdatesAsync 작업 처리 시간 1024 k blob 업데이트 및 다른 하드 드라이브 활동 없음.**

![](../../images/connected_storage/submitupdatesasync_proc_time_mixed_size_fixed_interval.png) 그림 14 세 가지에 대 한 처리 시간을 보여 줍니다. 1024 k blob 다양 한 시간 간격입니다.

시스템은 87ms 안정적인 상태에서 3 초 간격으로 이러한 업데이트를 처리할 수 있습니다. 2 초 마다 한 번에 빈도 늘리면, 시스템 87ms 안정적인 상태 내에서 업데이트를 처리할 여전히 수 있습니다.

업데이트 간에 1 초 간격을 줄이는 안정적인 상태 동작을 변경 합니다. 시스템 업데이트 당 87ms 60 업데이트를 처리할 수 있지만 모든 업데이트가 그 외에도 훨씬 더 오래 걸리면, 업데이트, 중요 한 변동 초 500 밀리초는 안정적인 상태 처리 시간에 도달 합니다. 16MB 메모리 버퍼가 디스크에 데이터를 플러시할 수 것 보다 더 빠르게 채워지고 이므로 업데이트는 이전 업데이트를 쓸 때까지 대기 해야 했습니다.

0.5 초 마다 한 번의 업데이트 간격을 업데이트할 때 효과 크게 높입니다. 시스템에서 각 업데이트는 1 초 이상에 매우 높은 처리 해야 하는 안정적인 상태에 도달 하기 전에 업데이트 당 87ms이이 간격에 따라 7만 업데이트를 다시 처리할 수 있습니다.

**그림 15입니다.  세 가지 함수의 처리 시간 1024 k blob 다양 한 시간 간격입니다.**

![](../../images/connected_storage/submitupdatesasync_proc_time_fixed_size_various_intervals.png) 이들은 설명을 예일 뿐입니다. 앱 일반적으로 않아야 데이터가 저장이 종종 아직 것도 없습니다 일반적으로 작동할 수 디스크 I/O의 무료 환경에서입니다.

이러한 예제에 따라 시스템의 특징을 이해 하는 것이 반드시-모드로 작동 조건을, 저장 작업은 1 초 미만의 앱 중에서 완료할 수 있도록 다양 한 응용 프로그램을 측정 하는 처리기 일시 중단의 합니다.


## <a name="synchronizing-a-connected-storage-space"></a>연결 된 저장소 공간을 동기화합니다.

-   연결 확인
-   잠금 획득
-   컨테이너 목록, 비교 및 병합 논리
-   컨테이너 다운로드

앱이 연결 된 저장소 공간에 대 한 액세스를 요청 하는 경우 시스템 Xbox One 콘솔에서 사용자의 저장 된 데이터를 일관 된 상태로 유지 하 고 자신의 데이터를 오프 라인 재생에 사용할 수 있도록 하는 동기화 프로세스를 수행 합니다. 때문에 동기화 다양 한 양의 시간을 걸릴 수 있습니다 수 결정 하는 사용자, 시스템은 프로세스의 여러 단계에서 UI를 사용자에 게 표시할 수 있습니다.

사용자는 동기화 UI 활성화 된 경우에 언제 든 지 Xbox 단추를 눌러 앱에서 탐색 합니다. 시스템 UI를 숨기고 사용자 개입 없이 가능와 관련해 서는 동기화가 계속 됩니다. 이동할 앱으로 다시 동기화가 완료 하지 않으면 UI는 다시 표시 됩니다. 시스템 UI가 표시 하는 경우 사용자 선택에 대 한 가정을 하지 않습니다 수 있습니다.

홈 화면에서 사용자가 앱의 렌더링은 큰 앱 타일에 여전히 나타나며 하는 경우 동기화가 UI를 표시 하는 시스템, 이므로 앱 하는 동안 컨텍스트에 따라 적절 한 시각적 개체를 렌더링 하는 **GetForUserAsync** 호출이 완료 됩니다. 앱도 대화형 이며 로드할 데이터를 기다리고 계속된 렌더링을 사용자에 게 나타냅니다.

다음 다이어그램에서는 시스템 앱에 연결 된 저장소 공간을 요청 하는 경우 다음과 같습니다. 대략적인 시퀀스를 설명 합니다. 전체 시퀀스에 둘 몇 초만에, 시스템에서 그린 동기화 UI 표시 됩니다.

**그림 16입니다.  앱 연결 된 저장소 공간을 요청 하는 경우 시스템에서 수행 하는 시퀀스입니다.**

![](../../images/connected_storage/app_requests_connected_storage_space.png) 시스템 서비스 하는 경우 다음 단계를 거칩니다를 **GetForUserAsync** 요청:

-   연결 확인
-   잠금 획득
-   컨테이너 목록, 비교 및 병합 논리
-   컨테이너 다운로드

### <a name="connectivity-check"></a>연결 확인

서비스를 시작 하는 **GetForUserAsync** 시스템 연결에 대 한 확인을 요청 합니다. 콘솔을 오프 라인 상태인 경우 전체 동기화 프로세스를 건너뛰고 지정된 된 사용자에 대 한 연결 된 저장소 공간이 현재 세션에 대 한 오프 라인으로 표시 됩니다. 수정 된 모든 데이터 조정 됩니다 클라우드 저장소를 사용 하 여 다음에 사용자의 연결 된 저장소 공간을 액세스 하는 앱 및 시스템 제목 저장소 서비스에 연결할 수 있습니다. UI는이 사례에 대 한 적이 표시 됩니다.

연결 된 저장소의 컨텍스트 외부에서 오프 라인 처리 하는 방법에 대 한 자세한 내용은 참조 *Xbox 하나 타이틀에 대 한 서비스 중단의 복원 력*합니다.

### <a name="lock-acquisition"></a>잠금 획득

연결을 확인 한 후 시스템 앱에서 현재 사용자와 연결 된 클라우드 저장소 공간에 대 한 단독 액세스를 가져오려고 시도 합니다. 제목 저장소의 연결 된 저장소 영역에서 잠금 파일을 배치 하면 됩니다. 콘솔 온라인, 서비스에 연결할 수 고를 짧은 시간 내에 잠금을 획득할 수에 UI 표시 되 고 동기화 프로세스가 계속 됩니다.

시스템에 특정 연결 된 저장소 공간에 대 한 잠금을 획득 하 고 앱에 연결 된 저장소 공간 인스턴스를 반환, 성공적인 웹 요청에 연결 된 저장소 공간을 차단 하 게 내 데이터에 대해 운영 없는 앱의 API를 호출 합니다. 잠금을은 API 호출을 앱에 연결 된 저장소 공간을 가져온 후 시스템에서 네트워크 케이블을 분리 하는 사용자 인 경우에 로컬로 사용할 수 있는 데이터를 기반으로 작동 되도록 충분 한 보호를 제공 합니다.

잠금 획득 단계 중 몇 가지 가능한 오류 시나리오는

 **UI 동기화** 콘솔은 온라인 상태 이지만 짧은 시간 내에 서비스에서 잠금을 획득 하지 않습니다, 경우에 "동기화" UI를 표시 됩니다.

 **잠금을 주요** 사용자 자신이 현재에 마지막으로 재생 하므로 다른 콘솔 앱을 재생 된, 경우 다른 콘솔에서 단독으로 저장소 공간을 데이터를 업로드 하는 중입니다. 다른 콘솔에 데이터 업로드를 시작한 있지만 완료 하기 전에 해당 연결 또는 전원 손실에 이기도 합니다.

두이 경우 모두 이라고 *잠금 경합*, 시스템 하 든에서 다른 데이터를 업로드 하 고 있는지를 설명 하는 UI를 제공 합니다. 사용자는이 프로세스를 완료 하거나 클라우드에서 현재 사용 가능한 데이터를 사용 하 여 작업을 기다릴 수 있습니다. 시스템에 대 한 잠금을 가져옵니다 클라우드 데이터를 사용 하 여 작업을 선택 하는 경우 자체 (하면 잠금이 해제), 사용자 및 앱에 대 한 클라우드 저장소에 대 한 단독 액세스를 획득 합니다. 다른 콘솔에서 업로드 취소 되 고 동기화 프로세스가 계속 됩니다.

### <a name="container-listing-comparison-and-merger-logic"></a>컨테이너 목록, 비교 및 병합 논리

잠금을 가져오면 시스템 사용자 지정된 앱을 클라우드에서 모든 컨테이너 목록을 요청 합니다. 그런 다음 클라우드에서 데이터를 사용 하 여 로컬 하드 드라이브의 내용을 비교 하 고 비교 결과 따라 진행 됩니다.

 **로컬 데이터 일치 클라우드에** 다른 콘솔에서 없는 변경 내용이 데이터를 클라우드에서, 그리고 로컬 하드 드라이브는 동일 하 고 동기화가 완료, 완료 처리기의 경우는 **GetForUserAsync**이때 호출 되 고 앱 로드 및 저장을 사용 하 여 진행할 수 있습니다.

 **로컬 데이터가 없는** 클라우드 로부터 데이터를 로컬로 다운로드 클라우드 데이터가 로컬 콘솔이 없는 경우. 이 발생할 수 있습니다, 예를 들어 사용자 친구의 집에서 처음으로 수행 하는 경우.

 **로컬 및 클라우드를 수정 하는 동일한 컨테이너** 데이터 사용자가 다른 콘솔에서 재생 하 여 클라우드에서 컨테이너를 수정 하 고 오프 라인으로 현재 콘솔을 사용 하는 경우 동일한 컨테이너를 수정 하는 경우 자동으로 병합할 수 없습니다. 사용자는 데이터 유지를 선택 하 라는 메시지가 표시 됩니다. 충돌을 발생할 경우 대체 정책이 선택할 수 있습니다. 클라우드 데이터를 로컬 데이터는 항상 유지, 또는 사용자가 선택할 수 **취소** 선택할 따릅니다. 대체 정책, 동일한 이름의 컨테이너도 사용자가 클라우드 또는 로컬 데이터 경우-하지만 다른 내용을-적절 하 게 해결 될 예정입니다.

사용자가 선택 **취소**, 제목에 액세스 해야 합니다. 해결 되지 않은 상태의 시스템 사용자는 오프 라인 재생 된 것 처럼 합니다. 이 경우 충돌을 해결 UI 콘솔 온라인 상태 이면 다음에 연결 된 저장소 공간에 대 한 액세스를 요청 하는 앱에 표시 됩니다.

### <a name="container-download"></a>컨테이너 다운로드

모든 충돌이 해결 된 후 시스템에 클라우드에서 다운로드 해야 하는 컨테이너를 식별 하는 데 필요한 모든 정보가 있습니다. 모든 필수 컨테이너 다운로드 되며, 완료 처리기를 *ConnectedStorageSpace.GetForUserAsync 메서드* 이때 호출 되 고 응용 프로그램 로드 및 저장을 사용 하 여 진행할 수 있습니다.

이 단계 중 오류가 발생할 수 있습니다.

**로컬 저장소 부족**  
필요한 컨테이너에 대 한 공간 부족 하 여 로컬 하드 드라이브의 경우 사용자가 로컬로 저장 된 데이터를 제거 하 여 디스크 공간을 확보 하도록 요청 하기 UI를 사용 하 여 표시 됩니다. UI를 클라우드에 백업 되지 않은 중요 한 데이터를 영구적으로 삭제 되지 않도록를 돕기 위해 단순히 로컬 캐시는 데이터 및 현재 콘솔에 고유한 데이터를 명확 하 게 나타냅니다.

경우 UI는 사용자에 게 표시 됩니다.

-   사용자를 충분 한 공간이 확보 하는 경우 동기화는 계속 하 고 완료 합니다.
-   사용자가 충분 한 공간이 완료 처리기를 해제 하지 않고 UI를 취소 합니다 **GetForUserAsync** 호출이 반환 **OutOfLocalStorage**-참조 *ConnectedStorageErrorStatus 열거형*합니다. 앱은 사용자가 데이터를 저장할 수는 없지만 재생 하려는 확인 해야 합니다. 사용자가 동의 하는 경우 앱 사용자에 대 한 데이터를 저장 하지 않고 진행 해야 합니다. 앱을 반복 해야 하는 경우 사용자 나타냅니다 재생 하는 동안 데이터를 저장 하려고 합니다 **GetForUserAsync** 호출을 UI 공간을 확보 한 후 표시 됩니다.

**사용자가 동기화 취소**  
와 사용자 동기화가 완료를 대기 하지 않습니다 및 선택 취소 하는 경우 사용자는 알림을 받습니다 저장된 된 데이터 중 일부만 제공 됩니다. 완료 처리기를 **GetForUserAsync** 이때 호출 됩니다 하 고 앱이 로드 및 저장을 사용 하 여 진행할 수 있습니다.

**네트워크 시간 제한**  
데이터가 네트워크 연결 또는 서비스 가용성 문제로 인해 시간 초과 다운로드 하는 경우 동기화를 다시 시도 하는 옵션을 사용자에 부여 됩니다. 자신이 하지 않도록 선택 하면 사용자가 알림이 저장된 된 데이터 중 일부만 제공 됩니다. 완료 처리기를 **GetForUserAsync** 이때 호출 됩니다 하 고 앱이 로드 및 저장을 사용 하 여 진행할 수 있습니다.

## <a name="development-tools"></a>개발 도구

두 도구에서는 연결 된 저장소의 사용 하 여 앱의 개발: XbStorage와 Fiddler입니다.

### <a name="managing-connected-storage-with-xbstorage"></a>XbStorage 사용 하 여 연결 된 저장소 관리

XbStorage는 개발 도구 개발 PC에서에서는 Xbox One 개발 키트에서 로컬 연결 된 저장소 데이터를 관리할 수 있도록 합니다.

도구에는 하드 드라이브에서 로컬 연결 된 저장소 공간을 지우고 가져오기 뿐만 아니라 XML 파일을 사용 하 여 개별 사용자 또는 컴퓨터-연결 저장소 공간을 내보낼 수 있습니다.

로컬 연결 된 저장소 공간에서 작업을 수행 하면 시스템 처럼 앱 자체가 해당 작업을 수행 했습니다. 로컬 파일에 연결 된 저장소 공간에서 데이터를 복사 하면 복사 하기 전에 클라우드로 동기화가 됩니다.

마찬가지로, Xbox One dev 키트에서 연결 된 저장소 컨테이너에 개발 PC에 대 한 XML 파일에서 데이터를 복사 하면 클라우드로 해당 데이터를 업로드 하려면 콘솔. 한 가지 예외가: dev 키트 잠금을 가져올 수 없습니다 또는 콘솔에서 컨테이너와 클라우드 간에 충돌이 발생 하는 경우. 이러한 경우 콘솔 처럼 충돌을 해결할 필요가 결정 했 고 사용자-유지할 컨테이너의 버전을 선택 하 여 예를 들어-콘솔 것를 제목 시작 될 때까지 오프 라인 재생 된 것 처럼 동작 하 고 있습니다.

XbStorage의 다시 설정 명령이 모든 SCIDs' 및 사용자의 저장 된 데이터의 로컬 저장소 지워지지만 클라우드에 저장 된 데이터를 변경 하지 않습니다. 콘솔 사용자는 콘솔에 로밍 되었으며 제목을 재생 시 클라우드에서 데이터를 다운로드 하는 경우에 것 상태로 설정 하는 것에 대 한 유용 합니다.

XbStorage에 대 한 자세한 내용은 참조 하세요. *연결 된 저장소 관리 (xbstorage.exe)*, XDK 설명서에서.

### <a name="monitoring-connected-storage-network-activity-using-fiddler"></a>Fiddler를 사용 하 여 연결 된 저장소 네트워크 작업 모니터링

클라우드 저장소 작업을 수행할 때 콘솔 서비스 상호 작용 하는지 여부를 확인할 수 있습니다. Fiddler를 사용 하 여 콘솔 호출 합니다. 서비스에 성공적으로 권한 부여 오류를 발생 하는 여부를 확인할 수 있습니다. Xbox One에서 Fiddler 설정에 대 한 정보를 참조 하세요 *Xbox One을 사용 하 여 Fiddler를 사용 하는 방법을*,이 XDK 설명서.

## <a name="resources"></a>리소스

위의 리소스 외에도 다음에 도움이 될 수 앱 또는 제목 개발:

-   XDK 설명서에서 연결 된 저장소 개요
-   [프로세스 수명 관리](https://developer.xboxlive.com/_layouts/xna/download.ashx?file=ProcessLifetimeManagement_08_2013_qfe5.zip&folder=platform/aug2013xdk_qfe5/samples), 샘플 게임 개발자 네트워크 (GDN)에서 사용할 수 있는 샘플
-   ["Xbox One에 대 한 PLM (수명 관리) 프로세스"](https://developer.xboxlive.com/en-us/platform/development/education/Documents/PLM%20for%20Xbox%20One.aspx), GDN 백서에서 사용할 수 있는 백서
