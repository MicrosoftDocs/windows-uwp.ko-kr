#Android 및 iOS 개발자용 Windows 앱 개념 매핑

Android 또는 iOS 기술이나 코드를 사용하고 Windows 10 및 UWP(유니버설 Windows 플랫폼)로 이동하려는 개발자의 경우 세 가지 플랫폼 간에 플랫폼 기능과 지식을 매핑하는 데 필요한 모든 정보가 들어 있는 이 리소스를 참조하세요.

[iOS에서 UWP로 이동](ios-to-uwp-root.md)의 포팅 콘텐츠도 참조하세요.

## UI(사용자 인터페이스)

|  **일반적인 개념** | **Android** | **iOS** | **Windows 10 UWP** |
|  ------ | ------ | ------ | ------ |
|  **디자인 언어.** 플랫폼의 앱 모양과 동작을 규정하는 규칙 집합입니다. | **Android 자료 디자인** 지침에서는 Android 디자이너 및 개발자를 위한 시각적 언어를 제공합니다. | **휴먼 인터페이스 지침**에서는 iOS 디자이너 및 개발자를 위한 권장 사항을 제공합니다. | [
            **UWP Windows 앱 디자인**](https://dev.windows.com/design)에서는 모든 Windows 10 디바이스에서 올바르게 표시되는 앱을 만드는 방법을 보여 줍니다. UI(사용자 인터페이스) 디자인 기본 사항, 반응형 디자인 기술 및 자세한 지침의 전체 목록을 찾을 수 있습니다.<br/> |
|  **사용자 인터페이스 생성 언어.** UI와 해당 구성 요소를 렌더링 및 설명하는 생성 언어입니다. 각 플랫폼은 디자인 및 태그 편집을 위한 편집기를 제공합니다.<br/> | **Android Studio** 또는 **Eclipse**를 사용하여 편집된 **XML 레이아웃** | Xcode 내의 **인터페이스 작성기**를 사용하여 편집된 **XIB** 및 **스토리보드** | **
            [Microsoft Visual Studio](https://www.visualstudio.com/)** 및 **[Blend for Visual Studio](https://msdn.microsoft.com/library/jj171012.aspx)**를 사용하여 편집된 **[XAML](https://msdn.microsoft.com/library/windows/apps/xaml/mt185595.aspx)**<br/><br/>[XAML 플랫폼](https://msdn.microsoft.com/library/windows/apps/xaml/mt228259.aspx)<br/><br/>[XAML을 사용하여 UI 만들기](https://msdn.microsoft.com/library/windows/apps/xaml/mt228349.aspx)<br/><br/>[XAML을 사용하여 레이아웃 정의](https://msdn.microsoft.com/library/windows/apps/xaml/mt228350.aspx) |
|  **기본 제공 사용자 인터페이스 컨트롤.** 단추, 목록 컨트롤, 텍스트 컨트롤 등 플랫폼에서 제공하는 재사용 가능 UI 요소입니다. | 클래스 위젯, 레이아웃, 텍스트 필드, 컨테이너, 날짜/시간 컨트롤 및 전문가 컨트롤이라고도 하는 미리 만들어진 **보기** 및 **보기 그룹**입니다. | Xcode 개체 라이브러리에 있고 UIKit 사용자 인터페이스 카탈로그에 나열된 **보기** 및 **컨트롤**입니다. 보기에는 이미지 보기, 선택기 보기 및 스크롤 보기가 있습니다. 컨트롤에는 단추, 날짜 선택 및 텍스트 필드가 포함됩니다. | XAML 플랫폼은 단추, 목록 컨트롤, 패널, 텍스트 컨트롤, 명령 모음, 선택기 및 수동 입력 등 일반적인 **기본 제공 컨트롤** 집합을 제공합니다.<br/><br/>[컨트롤 추가 및 이벤트 처리](https://msdn.microsoft.com/library/windows/apps/xaml/mt228345.aspx) |
|  **이벤트 처리 제어.** 이벤트는 UI 컨트롤 내에서 트리거될 때 실행되는 논리를 정의합니다. | **이벤트 처리기** 및 **이벤트 수신기**는 XML 또는 프로그래밍 방식으로 추가됩니다. | 컨트롤은 **작업** 메시지를 **대상**으로 보냅니다. | XAML 페이지에 연결된 **코드 숨김 파일**에서 XAML 컨트롤의 이벤트를 처리하는 메서드를 정의할 수 있습니다. **이벤트 처리기**는 항상 코드로 작성됩니다. 그러나 XAML 태그 또는 코드에서 이러한 처리기를 이벤트에 후크할 수 있습니다.<br/><br/>[컨트롤 추가 및 이벤트 처리](https://msdn.microsoft.com/library/windows/apps/xaml/mt228345.aspx)<br/><br/>[이벤트 및 라우트된 이벤트 개요](https://msdn.microsoft.com/library/windows/apps/xaml/mt185584.aspx) |
|  **데이터 바인딩.** 앱 UI에서 데이터를 렌더링하고 선택적으로 해당 데이터와의 동기화 상태를 유지할 수 있는 소프트웨어 디자인 패턴입니다.  | 베타 버전이지만 **데이터 바인딩 라이브러리**를 제공합니다. | iOS에는 기본 제공 바인딩 시스템이 없습니다. **KVO(Key-Value Observing)**를 빌드하여 타사 라이브러리를 사용하거나 추가 코드를 작성하여 데이터 바인딩을 수행할 수 있습니다. 컨트롤은 대리자/콜백 접근 방식을 사용하여 데이터를 가져옵니다. | UWP 플랫폼에서 **데이터 바인딩**을 처리합니다. **
            [{x:Bind}](https://msdn.microsoft.com/library/windows/apps/mt204783.aspx)** 태그 확장을 사용하여 고성능 바인딩을 이용하거나 **[{Binding}](https://msdn.microsoft.com/library/windows/apps/mt204782.aspx)**을 사용하여 더 많은 기능을 활용합니다. 그런 다음 바인딩을 구성하여 플랫폼에서 **단방향 바인딩**을 통해 UI에 데이터 원본의 값을 표시할지, 아니면 **양방향 바인딩**으로 변경하여 해당 값을 관찰하고 UI를 업데이트할지 선택할 수 있습니다.<br/><br/>[데이터 바인딩](https://msdn.microsoft.com/library/windows/apps/mt210947.aspx) |
|  **UI 자동화.** UI 요소에 대한 프로그래밍 방식의 액세스, 보조 기술 제품에 액세스할 수 있는 앱 만들기 및 UI를 조작하는 자동화된 테스트 스크립트 설정입니다. | **텍스트 레이블**, **contentDescription** 및 **hint** 값을 사용하면 자동화에서 UI 요소를 찾을 수 있습니다. Android Studio를 사용하면 **UI Automator** 및 **Espresso** 테스트 프레임워크를 사용하여 UI 테스트를 작성할 수 있습니다. | **자동화 방법**을 사용하면 **접근성** 설정 또는 **요소 계층 구조**의 요소 위치를 사용하여 요소를 식별하는 자동화된 UI 테스트 스크립트를 작성할 수 있습니다. | **
            [UI 자동화](https://msdn.microsoft.com/library/windows/apps/ee684076.aspx)**를 사용하여 기본 UWP의 기본 제공 UI 요소에 프로그래밍 방식으로 액세스합니다.<br/>**
            [사용자 지정 자동화 피어](https://msdn.microsoft.com/library/windows/apps/mt297667.aspx)**를 사용하면 고유한 사용자 지정 UI 클래스에 대한 자동화 지원을 제공할 수 있습니다. Visual Studio의 **[코딩된 UI 테스트 프로젝트](https://msdn.microsoft.com/library/dd286726.aspx#VerifyingCodeUsingCUITCreate)**를 사용하면 UI를 통해 전체 응용 프로그램을 자동으로 테스트하거나 격리된 상태에서 UI를 테스트할 수 있습니다. |
|  **컨트롤의 모양 변경** 크기, 색 및 기타 특성을 편집합니다. | 컨트롤에는 디자이너 도구를 사용하여 XML 태그 또는 프로그래밍 방식으로 편집할 수 있는 **속성**이 있습니다. | 컨트롤에는 **특성 검사기**를 사용하여 인터페이스 작성기 또는 프로그래밍 방식으로 편집할 수 있는 **특성**이 있습니다. | Visual Studio 및 Blend for Visual Studio를 사용하여 XAML 태그 또는 프로그래밍 방식으로 컨트롤의 **속성**을 편집할 수 있습니다.<br/><br/>[컨트롤 추가 및 이벤트 처리](https://msdn.microsoft.com/library/windows/apps/xaml/mt228345.aspx) |
|  **재사용 가능한 시각적 스타일.** 재사용 가능한 형식으로 여러 컨트롤에 시각적 변경 사항을 적용합니다. | **XML 스타일**은 하나 이상의 컨트롤에 적용되는 속성 집합입니다. | iOS는 기본으로 제공하는 재사용 가능한 시각적 스타일을 지원하지 않지만 UIAppearance 프로토콜을 사용하면 여러 컨트롤에서 공통 특성을 공유할 수 있습니다. | 쉽게 재사용할 수 있도록 여러 컨트롤에 적용할 수 있는 재사용 가능한 **[스타일](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.style.aspx)**을 만들어 **[ResourceDictionary](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.resourcedictionary.aspx)**에 저장할 수 있습니다.<br/><br/>[빠른 시작: 컨트롤 스타일 지정](https://msdn.microsoft.com/library/windows/apps/xaml/hh465381.aspx) |
|  **컨트롤의 시각적 구조 편집.** 속성 또는 특성을 수정하는 것 외에 확인란 아래의 확인란 텍스트를 이동하는 등 컨트롤의 시각적 구조를 사용자 지정합니다. | Android에서 컨트롤의 시각적 구조를 간단히 편집할 수 있는 방법은 없습니다. | iOS에서 컨트롤의 시각적 구조를 간단히 편집할 수 있는 방법은 없습니다. | 컨트롤의 시각적 구조를 사용자 지정하려면 XAML 태그에서 해당 **[컨트롤 템플릿](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.controls.controltemplate.aspx)**을 복사 및 편집할 수 있습니다.<br/><br/>[빠른 시작: 컨트롤 템플릿](https://msdn.microsoft.com/library/windows/apps/xaml/hh465374.aspx)  |
|  **기본 제공 터치 제스처.** 보기 및 컨트롤에서 탭하기 및 두 번 탭하기 등 수준 높은 추상화 제스처 이벤트를 처리하여 사용자 지정된 터치 지원을 제공합니다. | **제스처 탐지기**는 스크롤, 길게 누르기, 탭하기, 두 번 탭하기 및 플링 등 일반적인 터치 제스처를 감지합니다. | UIKit 프레임워크는 탭하기, 손가락 모으기, 이동, 살짝 밀기, 회전 및 길게 누르기 등 기본 제공 **제스처 인식기**를 제공합니다. | **UI 요소**를 사용하면 탭하기, 두 번 탭하기, 오른쪽 탭하기 및 누르고 있기 등의 **정적 제스처 이벤트**뿐 아니라 밀기, 살짝 밀기, 돌리기, 손가락 모으기 및 늘이기 등의 **조작 제스처 이벤트**도 처리할 수 있습니다. 제스처 이벤트는 **라우트된 이벤트**이며 자식 UIElement를 포함하는 부모 개체에서 처리될 수 있습니다.<br/><br/>[터치 조작](https://msdn.microsoft.com/library/windows/apps/mt185617.aspx)<br/><br/>[사용자 지정 사용자 조작 - 제스처, 조작 및 조작 방식](https://msdn.microsoft.com/library/windows/apps/mt185599.aspx#gestures__manipulations__and_interactions) |

## 탐색 및 앱 구조

|  **일반적인 개념** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **레이아웃.** 레이아웃은 사용자 인터페이스의 구조를 정의합니다. | 레이아웃은 다른 보기 그룹 또는 보기를 중첩할 수 있는 **LinearLayout** 및 **RelativeLayout** 등의 **보기 그룹**으로 구성됩니다. | 레이아웃은 중첩 가능한 **UIView**를 포함하는 **UIViewController**로 구성됩니다.  | 정적 및 반응형 레이아웃을 위한 **[Canvas](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.canvas.aspx)**, **[Grid](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.grid.aspx)**, **[RelativePanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.relativepanel.aspx)** 및 **[StackPanel](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.stackpanel.aspx)** 등의 **레이아웃 패널 클래스**로 구성된 유연한 레이아웃 시스템을 제공하는 XAML입니다. **
            [속성](https://msdn.microsoft.com/library/ms171352.aspx)**은 요소의 위치와 크기를 제어하는 데 사용됩니다.<br/><br/>[XAML을 사용하여 레이아웃 정의](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx)<br/> |
|  **피어 투 피어 탐색.** 사용자에게 계층적 중요도가 동일한 페이지 간을 이동하는 방법을 제공합니다. | **탭**, **살짝 밀기 보기** 및 **탐색 창**은 **측면 탐색**을 제공합니다. | **탭 바 컨트롤러**, **분할 보기 컨트롤러** 및 **페이지 보기 컨트롤러**를 사용하면 동일한 계층의 보기 간을 탐색할 수 있습니다. | **
            [탭/피벗](https://msdn.microsoft.com/library/windows/apps/dn997788.aspx)**을 사용하여 콘텐츠 위에 링크/탭의 영구 목록을 표시할 수 있습니다. **
            [탐색 창/분할 보기](https://msdn.microsoft.com/library/windows/apps/dn997787.aspx)**를 사용하면 콘텐츠와 함께 링크 목록을 표시할 수 있습니다.<br/><br/>[탐색](https://msdn.microsoft.com/library/windows/apps/mt187344.aspx)<br/><br/>[두 페이지 간의 피어 투 피어 탐색](https://msdn.microsoft.com/library/windows/apps/mt465735.aspx) |
|  **계층적 탐색.** 계층에서 부모와 자식 페이지 간을 탐색합니다. | **목록**, **그리드 목록**, **단추** 및 기타 컨트롤은 **의도**와 함께 사용하여 다른 **활동**을 로드할 때 **하위 탐색**을 제공합니다. | **탐색 컨트롤러**를 사용하면 사용자가 계층 구조 수준 간을 탐색할 수 있습니다. | **
            [허브](https://msdn.microsoft.com/library/windows/apps/dn449149.aspx)**를 사용하면 하위 페이지로 이동하는 데 선택할 수 있도록 사용자에게 콘텐츠의 미리 보기를 표시합니다. **
            [마스터/세부 정보](https://msdn.microsoft.com/library/windows/apps/dn997765.aspx)**를 사용하면 사용자가 해당 세부 정보 섹션 옆에 표시되는 항목 요약 목록에서 선택할 수 있습니다.<br/><br/>[탐색](https://msdn.microsoft.com/library/windows/apps/mt187344.aspx) |
|  **뒤로 단추 탐색.** 응용 프로그램을 통해 뒤로 탐색합니다. | 작업 모음 내의 **뒤로** 및 **위로** 단추는 **백 스택**을 사용하여 **상위** 및 **임시** 탐색을 제공합니다. | **탐색 컨트롤러**에 뒤로 단추를 추가할 수 있습니다.<br/> | 사용자가 **탐색 기록**을 트래버스할 수 있는 **[백 스택 속성](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.frame.backstack.aspx)**을 사용하여 소프트웨어 또는 하드웨어 뒤로 단추 누르기를 쉽게 처리할 수 있습니다.<br/><br/>[뒤로 단추 탐색](https://msdn.microsoft.com/library/windows/apps/mt465734.aspx) |
|  **시작 화면.** 앱 실행 시 이미지를 표시하며 브랜딩에 주로 사용됩니다. | 시작 화면은 기본적으로 제공되지 않으며 첫 번째 활동 **테마 배경**을 편집하여 구현됩니다. | 앱에는 **정적 시작 이미지** 또는 **XIB/스토리보드 시작 파일**이 있어야 합니다. | **이미지** 및 색상이 있는 배경을 사용하여 시작 화면을 만듭니다. [시작 화면 시간을 확장할 수 있습니다](https://msdn.microsoft.com/library/windows/apps/mt187309.aspx).<br/><br/>[시작 화면 추가](https://msdn.microsoft.com/library/windows/apps/mt187306.aspx)<br/><br/>[시작 화면에 대한 지침](https://msdn.microsoft.com/library/windows/apps/hh465338.aspx) |

## 사용자 지정 입력

|  **일반적인 개념** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **음성.** 음성 입식 및 추가 음성 기능을 위해 음성을 인식합니다. | 음성 입력은 **Google 음성 검색** 등의 **RecognizerIntent**를 구현하는 앱에서 제공할 수 있습니다. **SpeechRecognizer** 클래스를 사용하면 앱에서 Google의 음성 인식 API를 사용할 수 있습니다. | 기본 제공 음성 인식 또는 음성 입력 API는 없습니다. | **
            [음성 인식](https://msdn.microsoft.com/library/windows/apps/mt185615.aspx)** API를 사용하여 포그라운드에서 앱을 조작할 수 있습니다. 음성 기반 **[Cortana 조작](https://msdn.microsoft.com/library/windows/apps/mt185598.aspx)**을 사용하여 포그라운드 또는 백그라운드에서 앱을 시작하고 백그라운드 앱을 조작합니다.<br/><br/>[음성 조작](https://msdn.microsoft.com/library/windows/apps/mt185614.aspx) |
|  **사용자 지정 사용자 입력.** 키보드, 마우스, 스타일러스 및 기타 입력을 처리합니다. | **터치**, **터치 패드**, **스타일러스**, **마우스** 및 **키보드** 조작이 지원됩니다. 동작 및 입력은 터치와 동일한 방식으로 보고되지만 **입력 디바이스**에 대한 더 많은 정보를 검색할 수 있습니다. | **터치**, **Apple 연필** 및 하드웨어 **키보드**에 대한 지원이 제공됩니다. | **
            [터치](https://msdn.microsoft.com/library/windows/apps/mt185617.aspx)**, **[터치 패드](https://msdn.microsoft.com/library/windows/apps/mt187313.aspx)**, 디지털 잉크를 사용하는 **[펜/스타일러스](https://msdn.microsoft.com/library/windows/apps/mt187311.aspx)**, **[마우스](https://msdn.microsoft.com/library/windows/apps/mt187308.aspx)** 및 **[키보드](https://msdn.microsoft.com/library/windows/apps/mt185607.aspx)**를 포함하여 다양한 조작이 지원됩니다. 사용된 입력 디바이스와 필요한 경우 원시 입력 디바이스 데이터에 액세스할 수 있는 여부를 몰라도 앱에서 데이터를 처리할 수 있습니다.<br/><br/>[포인터 입력 처리](https://msdn.microsoft.com/library/windows/apps/mt404610.aspx)<br/><br/>[사용자 지정 사용자 조작](https://msdn.microsoft.com/library/windows/apps/mt185599.aspx) |

## 데이터

|  **일반적인 개념** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **로컬 앱 데이터.** 앱 관련 설정 및 파일을 로컬로 앱에 저장합니다. | 로컬 파일은 **openFileOutput** 및 **openFileInput**을 사용하여 저장할 수 있습니다. **공유 기본 설정 파일**의 설정은 **getSharedPreferences**를 사용하여 액세스할 수 있습니다. | 로컬 파일은 **NSFileManager** 클래스를 통해 액세스되는 **응용 프로그램 지원** 디렉터리에 저장할 수 있습니다. **기본 설정** 파일의 설정은 **NSUserDefaults** 클래스에서 액세스할 수 있습니다. | **
            [Windows.Storage](https://msdn.microsoft.com/library/windows/apps/xaml/br230562.aspx)** 클래스는 통합된 방식으로 로컬 데이터 저장소를 처리합니다. **
            [ApplicationData.LocalSettings](https://msdn.microsoft.com/library/windows/apps/xaml/windows.storage.applicationdata.localsettings.aspx)** 속성을 통해 액세스하는 **[ApplicationDataContainer](https://msdn.microsoft.com/library/windows/apps/xaml/windows.storage.applicationdatacontainer.aspx)** 개체로 설정을 저장합니다. **
            [ApplicationData.LocalFolder](https://msdn.microsoft.com/library/windows/apps/xaml/windows.storage.applicationdata.localfolder.aspx)** 속성을 통해 액세스하는 **[StorageFolder](https://msdn.microsoft.com/library/windows/apps/windows.storage.storagefolder.aspx)** 개체에 파일을 저장합니다.<br/><br/>[설정 및 기타 앱 데이터 저장 및 검색](https://msdn.microsoft.com/library/windows/apps/xaml/mt299098.aspx) |
|  **로컬 데이터베이스 저장소.** 해당하는 경우 ORM(개체 관계형 매퍼)을 사용하여 관계형 데이터베이스에 앱 데이터를 저장합니다. | **SQLite** 데이터베이스가 제공됩니다. 기본 제공 ORM은 없습니다. SQL 쿼리는 **SQLiteDatabase** 클래스를 사용하여 실행됩니다. | **SQLite** 데이터베이스가 제공됩니다. **CoreData**는 SQLite와 함께 사용할 수 있는 기본 제공 개체 그래프 프레임워크이며 ORM과 비슷한 기능을 제공합니다. | **SQLite**를 사용하여 데이터를 저장할 수 있습니다. **
            [Entity Framework](https://msdn.microsoft.com/library/windows/apps/xaml/mt592863.aspx)**는 많은 데이터 액세스 코드를 작성할 필요가 없으며 SQL 작성 없이도 데이터베이스를 쉽게 쿼리할 수 있는 기본 제공 ORM입니다. [SQLite 라이브러리](https://msdn.microsoft.com/library/windows/apps/xaml/mt592864.aspx)를 사용하여 직접 SQL 쿼리를 직접 실행할 수 있습니다.<br/><br/>[데이터 액세스](https://msdn.microsoft.com/library/windows/apps/xaml/mt592862.aspx) |
|  **REST 액세스용 HTTP 라이브러리.** HTTP(S)를 사용하여 웹 서비스 및 웹 서버와 통신할 수 있는 기본 제공 라이브러리입니다.<br/> | HTTP 라이브러리 **HttpURLConnection** 및 **Volley**. | **NSURLSession**, **NSURLConnection** 및 **NSURLDownload**. | 기본 제공 **[HttpClient](https://msdn.microsoft.com/library/windows/apps/xaml/windows.web.http.httpclient)** API를 사용하여 GET, DELETE, PUT, POST, 일반 인증 패턴, SSL, 쿠키, 진행 정보를 포함한 일반 HTTP 기능에 액세스할 수 있습니다. |
|  **클라우드 백업 서비스.** 앱 데이터를 위해 플랫폼에서 제공한 백업 서비스입니다.  | Android의 **백업 관리자**는 Google의 **Android 백업 서비스**에서 응용 프로그램 데이터 백업을 처리합니다.  | 사용자가 앱 데이터를 포함하여 해당 백업을 처리하도록 **iCloud 백업**을 구성할 수 있습니다. iCloud 호환 **핵심 데이터**, **iCloud 키-값 저장소** 및 **iCloud 문서 저장소**를 사용하는 앱입니다. | 로밍 **[ApplicationData API](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.aspx)**(**[RoamingFolder](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.roamingfolder.aspx)** 및 [**RoamingSettings**](https://msdn.microsoft.com/library/windows/apps/windows.storage.applicationdata.roamingsettings.aspx) 포함)를 사용하여 저장한 모든 앱 데이터는 자동으로 클라우드 및 사용자의 기타 디바이스와 동기화됩니다. 동기화는 사용자의 Microsoft 계정을 통해 수행됩니다.<br/><br/>[로밍 중인 앱 데이터 지침](https://msdn.microsoft.com/library/windows/apps/hh465094.aspx) |
|  **HTTP 파일 다운로드.** HTTP를 통해 크고 작은 파일을 다운로드합니다. | **URLConnection** 및 **HTTPURLConnection**은 HTTP 및 FTP를 통해 다운로드하는 데 사용되며 시스템 **다운로드 관리자**를 사용하여 백그라운드에서 다운로드할 수도 있습니다. | **NSURLSession** 및 **NSURLConnection**은 HTTP 및 FTP를 통해 파일을 다운로드하는 데 사용할 수 있습니다. | **
            [백그라운드 전송 API](https://msdn.microsoft.com/library/windows/apps/windows.networking.backgroundtransfer.aspx)**를 사용하면 HTTP(S) 및 FTP를 통해 파일을 안정적으로 전송하고, 앱 일시 중단, 연결 해제 및 연결성과 배터리 사용 시간에 따른 조정을 고려합니다. 적은 파일에 적합한 **[HttpClient](https://msdn.microsoft.com/library/windows/apps/windows.web.http.httpclient.aspx)**를 사용할 수도 있습니다.<br/><br/>[네트워킹 기술 선택](https://msdn.microsoft.com/library/windows/apps/mt280235.aspx)<br/><br/>[백그라운드 전송](https://msdn.microsoft.com/library/windows/apps/mt280377.aspx) |
|  **소켓.** 낮은 수준의 UDP 데이터그램 및 TCP 소켓을 만들어 사용자 고유의 프로토콜을 통해 다른 디바이스와 통신합니다. | **Socket** 클래스는 TCP 소켓을 제공하고 **DatagramSocket** 클래스는 UDP 소켓을 제공합니다. | **NSStream** 및 **CFStream**은 TCP 소켓을 제공하고 **CFSocket**은 UDP 소켓을 제공합니다. | **
            [DatagramSocket](https://msdn.microsoft.com/library/windows/apps/br241319)** 클래스를 사용하여 UDP 데이터그램 소켓을 통해 통신하고 **[StreamSocket](https://msdn.microsoft.com/library/windows/apps/br226882)** 클래스를 사용하여 TCP 또는 Bluetooth RFCOMM을 통해 통신할 수 있습니다.<br/><br/>[네트워킹 기본 사항](https://msdn.microsoft.com/library/windows/apps/mt280233.aspx)<br/><br/>[네트워킹 기술 선택](https://msdn.microsoft.com/library/windows/apps/mt280235.aspx)<br/><br/>[소켓 개요](https://msdn.microsoft.com/library/windows/apps/mt280234.aspx) |
|  **WebSockets.** 실시간 데이터 전송을 위해 클라이언트와 서버 간에 양방향 통신을 제공합니다. | Android에는 기본 제공 WebSockets 라이브러리가 없습니다. | iOS에는 기본 제공 WebSockets 라이브러리가 없습니다. | 수신 알림 기능이 있는 적은 메시지에 대해 **[MessageWebSocket](https://msdn.microsoft.com/library/windows/apps/windows.networking.sockets.messagewebsocket.aspx)** 클래스를 사용하고, 섹션에서 읽을 수 있는 대용량 이진 파일 전송에 대해 **[StreamWebSocket](https://msdn.microsoft.com/library/windows/apps/windows.networking.sockets.streamwebsocket.aspx)**을 사용하여 WebSockets를 지원하는 서버에 대한 연결을 보호합니다.<br/><br/>[네트워킹 기본 사항](https://msdn.microsoft.com/library/windows/apps/mt280233.aspx)<br/><br/>[네트워킹 기술 선택](https://msdn.microsoft.com/library/windows/apps/mt280235.aspx)<br/><br/>[WebSockets 개요](https://msdn.microsoft.com/library/windows/apps/mt186447.aspx) |
|  **OAuth 라이브러리.** 타사 OAuth 공급자에 대한 액세스를 허용하는 OAuth 라이브러리와 플랫폼에 기본 제공되는 계정 관리입니다. | 일반 OAuth 라이브러리는 제공되지 않습니다. Google Play Services를 사용한 OAuth 인증을 위해 **GoogleAuthUtil** 클래스가 제공됩니다.<br/> | 일반 OAuth 라이브러리는 제공되지 않습니다. **계정 프레임워크**는 Facebook 및 Twitter와 같이 디바이스에 이미 저장된 사용자 계정에 대한 액세스를 제공합니다. | 일반 OAuth 라이브러리 **[웹 인증 브로커](https://msdn.microsoft.com/library/windows/apps/mt270196.aspx)**를 사용하여 타사 ID 공급자 서비스에 연결할 수 있습니다. **
            [자격 증명 보관](https://msdn.microsoft.com/library/windows/apps/mt270189.aspx)**을 사용하여 사용자가 로그인을 저장하고 여러 디바이스에서 사용하도록 할 수 있습니다. **
            [Microsoft.Live](https://msdn.microsoft.com/library/windows/apps/dn896755.aspx)** 네임스페이스를 사용하면 Microsoft 서비스 액세스를 위해 Live SDK OAuth에 쉽게 액세스할 수 있습니다.<br/><br/>[인증 및 사용자 ID](https://msdn.microsoft.com/library/windows/apps/mt270184.aspx)<br/><br/>[Windows.Security.Authentication.Web API 설명서](https://msdn.microsoft.com/library/windows/apps/windows.security.authentication.web.aspx)<br/><br/>[WebAuthenticationBroker 코드 예제](https://github.com/Microsoft/Windows-universal-samples/tree/master/Samples/WebAuthenticationBroker) |

## 도구

|  **일반적인 개념** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **IDE.** 앱을 만드는 데 사용되는 도구 집합입니다. | **Android의 Studio** 및 **Eclipse**. Google에서는 개발자에게 Android Studio를 사용하도록 권장합니다. | **Xcode** | **
            [Visual Studio](https://www.visualstudio.com/features/universal-windows-platform-vs.aspx)** 및 **[Blend for Visual Studio](https://msdn.microsoft.com/library/jj171012.aspx)**에는 UWP 앱을 코딩, 디자인, 연결, 디버그, 분석, 최적화 및 테스트하는 데 필요한 모든 도구가 있습니다. Visual Studio에서는 Windows 10 디바이스용 **[에뮬레이터](https://msdn.microsoft.com/library/windows/apps/mt188754.aspx)**를 제공하므로 다양한 에뮬레이트 디바이스에서 앱을 테스트할 수 있습니다.<br/><br/>[UWP용 다운로드 및 도구](https://dev.windows.com/downloads) |
|  **코드 구성.** 앱의 기본 폴더 구조로, 초기 템플릿에서 생성됩니다. | **AndroidManifest** 파일, 소스 파일이 포함된 **java** 폴더, 레이아웃 및 값을 포함한 리소스가 있는 **res** 폴더, Android Studio의 **Gradle** 빌드 스크립트 및 Eclipse의 **Ant** 빌드 스크립트 | 소스 파일 및 **지원 파일**, **Info.plist** 파일, **Main.storyboard** 및 **LaunchScreen.storyboard**. 이미지는 **자산 라이브러리**에 저장됩니다. | UWP 앱에는 Example.xaml 및 Example.xaml.cs라는 앱에 대한 XAML 및 코드 파일, **Assets 폴더**의 다양한 이미지, **MainPage.xaml** 및 **MainPage.xaml.cs** 등의 시작 페이지 및 매니페스트가 포함됩니다.<br/><br/>[hello world 앱 만들기](https://msdn.microsoft.com/library/windows/apps/dn765018.aspx) |

## 앱 수명 주기

|  **일반적인 개념** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **앱 수명 주기.** 앱 시작, 일시 중단, 다시 시작 및 닫기 시 이벤트 처리는 응용 프로그램 상태를 저장/복원하고 다른 작업을 실행할 수 있는 기회를 제공합니다. | 각 작업에는 자체 **작업 수명 주기**와 **다시 시작** 등의 상태가 있습니다. **onResume** 등의 **수명 주기 콜백**은 **활동 클래스**에서 구현됩니다. | **응용 프로그램 수명 주기**에는 **일시 중단** 등의 상태가 있습니다. **applicationDidEnterBackground:**와 같은 메서드가 **응용 프로그램 대리자 개체**에서 구현되어 상태 변경 시 코드를 실행합니다. | 응용 프로그램의 **앱 실행 상태**는 NotRunning, Activated, Running, Suspending, Suspended 및 Resuming입니다.<br/><br/>상태가 변경될 때 앱에서 **[응용 프로그램 클래스](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.application.aspx)** 메서드 OnLaunched, OnActivated, Suspending 또는 Resuming을 구현하여 코드를 실행할 수 있습니다.<br/><br/>[앱 수명 주기](https://msdn.microsoft.com/library/windows/apps/mt243287.aspx) |
|  **백그라운드 작업.** 앱이 포그라운드에 없을 때 백그라운드 작업을 수행하고 실행을 계속하는 작업입니다. | 앱이 포그라운드에 없을 때 앱에서 백그라운드 작업을 수행하는 **서비스**를 시작할 수 있습니다. 서비스에는 자체 **수명 주기**가 있으며 매니페스트에 등록됩니다. | **백그라운드 실행**은 특정 작업 유형에만 사용할 수 있습니다.<br/><br/>**UIBackgroundModes**를 사용하여 앱에서 Info.plist 파일에 **지원되는 백그라운드 작업**을 선언합니다.<br/><br/>시스템은 백그라운드 작업을 실행할 시기와 기간을 제어합니다. | **
            [IBackgroundTask](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.ibackgroundtask.aspx)** 인터페이스를 구현하고 응용 프로그램 매니페스트에 작업을 등록하여 백그라운드 작업을 만들 수 있습니다. [
            **타이머**](https://msdn.microsoft.com/library/windows/apps/mt186458.aspx), [**시스템 트리거**](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.systemtriggertype.aspx), 및 [**유지 관리 트리거**](https://msdn.microsoft.com/library/windows/apps/mt185632.aspx)를 사용하여 트리거할 작업을 설정할 수 있습니다.<br/><br/>[백그라운드 작업을 사용하여 앱 지원](https://msdn.microsoft.com/library/windows/apps/mt299103.aspx)<br/><br/>[백그라운드 작업 만들기 및 등록](https://msdn.microsoft.com/library/windows/apps/mt299100.aspx)<br/><br/>[백그라운드 작업 지침](https://msdn.microsoft.com/library/windows/apps/mt187310.aspx) |

## 성능

|  **일반적인 개념** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **성능 모범 사례.** 시작 시간을 단축하면서 빠르고, 반응성이 뛰어나고, 배터리 사용 시간을 고려하는 앱을 작성하기 위한 지침입니다. | Android는 **성능 모범 사례** 교육 가이드를 제공합니다. | iOS는 **성능 개요** 문서를 제공합니다. | 성능 목표 설정, 성능 측정, 메모리 관리, 매끄러운 애니메이션, 효율적인 파일 시스템 액세스, 프로파일링 및 성능에 사용할 수 있는 도구 등에 대한 항목을 다루는 섹션이 포함된 자세한 **[성능 가이드](https://msdn.microsoft.com/library/windows/apps/mt270266.aspx)**를 참조할 수 있습니다. |
|  **반응형 UI에 대한 최적화 보기.** 보기를 최적화하여 성능을 향상시킵니다. | 계층적 뷰어 도구를 사용한 **레이아웃 계층** 최적화, **레이아웃 다시 사용** 및 **주문형 보기** 로드는 UI 스레드 응답을 유지하고 **ANR**("응용 프로그램이 응답하지 않음") 대화 상자를 방지하는 기술입니다.<br/> | **핵심 애니메이션** 도구를 사용하여 **오프스크린 렌더링**, **혼합 계층**, **래스터화**를 통해 UI 문제를 해결하면 UI 스레드 응답을 유지할 수 있습니다. | 몇 가지 간단한 단계에 따라 XAML **태그** 및 **레이아웃**을 쉽게 **최적화**할 수 있습니다. 기술에는 레이아웃 구조 줄이기, 요소 수 최소화 및 과도한 그리기 최소화가 포함됩니다. <br/><br/>[UI 스레드 응답 유지](https://msdn.microsoft.com/library/windows/apps/mt185403.aspx)<br/><br/>[XAML 태그 최적화](https://msdn.microsoft.com/library/windows/apps/mt204779.aspx)<br/><br/>[XAML 레이아웃 최적화](https://msdn.microsoft.com/library/windows/apps/mt404609.aspx) |
|  **스레딩.** 스레딩을 사용하여 **반응형 UI**를 유지하고 여러 **작업을 병렬로** 실행합니다. | 스레딩은 **Runnable**, **Handler**, **ThreadPoolExecutor** 및 높은 수준 **AsyncTask** 클래스를 통해 사용할 수 있습니다. | 스레딩은 **NSThread**, **Grand Central Dispatch** 및 높은 수준 **NSOperation**을 통해 사용할 수 있습니다. | **
            [RunAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.threading.threadpool.runasync.aspx)**를 사용하여 **작업 항목**을 **threadpool**에 제출하여 스레드 작업을 수행할 수 있습니다. 타이머를 사용하여 **[CreateTimer](https://msdn.microsoft.com/library/windows/apps/br230590.aspx)**로 작업 항목을 제출하고 **[CreatePeriodicTimer](https://msdn.microsoft.com/library/windows/apps/br230589.aspx)**로 반복 작업 항목을 만들 수 있습니다.<br/><br/>[스레드 풀에 작업 항목 제출](https://msdn.microsoft.com/library/windows/apps/mt187339.aspx)<br/><br/>[타이머를 사용하여 작업 항목 제출](https://msdn.microsoft.com/library/windows/apps/mt187341.aspx)<br/><br/>[정기 작업 항목 만들기](https://msdn.microsoft.com/library/windows/apps/mt187338.aspx)<br/><br/>[스레드 풀을 사용하기 위한 모범 사례](https://msdn.microsoft.com/library/windows/apps/mt187336.aspx) |
|  **비동기 프로그래밍.** 비동기 프로그래밍 패턴을 통해 UI 스레드 응답을 유지하여 스레딩 복잡성을 방지합니다.  | 자체 비동기 클래스를 만들려면 **스레딩 필요**를 사용합니다. 일부 기본 제공 클래스는 비동기입니다. | 자체 비동기 클래스를 만들려면 **스레딩 필요**를 사용합니다. 일부 기본 제공 클래스는 비동기입니다. | 자체 API를 만들 때 비동기 패턴(예: C# 및 Visual Basic의 **async** 및 **await**)을 사용하여 주 스레드 차단을 방지할 수 있습니다. 단어가 **Async**로 끝나는 비동기 기본 제공 API를 사용할 수 있습니다.<br/><br/>[비동기 프로그래밍](https://msdn.microsoft.com/library/windows/apps/mt187335.aspx)<br/><br/>[C# 또는 Visual Basic에서 비동기식 API 호출](https://msdn.microsoft.com/library/windows/apps/mt187337.aspx) |
|  **목록 보기 최적화.** 데이터 목록 최적화를 지원하는 기본 제공 패턴이며 많은 양의 데이터를 표시해야 할 경우 성능이 저하될 수 있습니다. | **ViewHolder** 디자인 패턴은 여러 보기 조회를 방지하는 데 사용됩니다. 이를 통해 재사용 가능한 UI 요소를 사용할 수 있습니다. | 다양한 최적화를 통해 **UITableView**의 성능을 향상시킬 수 있습니다. 기본 제공되는 항목은 없습니다. | 기본 **UI 가상화**를 제공하는 [ListView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.listview.aspx) 및 [GridView](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.gridview.aspx) 컨트롤을 사용하여 이동 및 스크롤 환경을 제공하고 시작 시간을 단축할 수 있습니다. 데이터 원본에서 [IList](https://msdn.microsoft.com/library/windows/apps/system.collections.ilist.aspx) 및 [INotifyCollectionChanged](https://msdn.microsoft.com/library/windows/apps/system.collections.specialized.inotifycollectionchanged.aspx)를 구현하여 **데이터 가상화** 및 개선된 성능을 제공할 수도 있습니다.<br/><br/>[ListView 및 GridView UI 최적화](https://msdn.microsoft.com/library/windows/apps/mt204776.aspx)<br/><br/>[ListView 및 GridView 데이터 가상화](https://msdn.microsoft.com/library/windows/apps/mt574120.aspx) |

## 수익 창출

|  **일반적인 개념** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **앱에서 바로 구매.** 사용자가 앱에서 구매할 수 있는 플랫폼 기능입니다. | **앱에서 바로 청구**는 Google 서비스에서 제공됩니다. 제품이 **Google Play 개발자 콘솔**에 추가됩니다. 앱에서 바로 구매는 **Google Play Billing Library**를 통해 구현됩니다. | 제품이 **iTunes Connect**에 추가됩니다. 앱에서 바로 구매는 **StoreKit** 프레임워크를 사용하여 구현됩니다.<br/><br/>제품은 **SKMutablePayment** 및 **SKPaymentQueue**를 사용하여 구매합니다. | [앱에 추가하고 스토어에 제출하여](https://msdn.microsoft.com/library/windows/apps/mt148551.aspx) 앱에서 바로 구매 제품 구매를 만듭니다. <br/><br/>**
            [CurrentApp 클래스](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentapp.aspx)**를 사용하여 앱에서 바로 구매를 정의합니다. <br/><br/>**
            [CurrentApp.RequestProductPurchaseAsync](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentapp.requestproductpurchaseasync.aspx)**를 사용하여 고객이 제품을 구매할 수 있는 UI를 표시합니다.<br/><br/>[앱에서 바로 제품 구매 사용](https://msdn.microsoft.com/library/windows/apps/mt219684.aspx) |
|  **앱에서 바로 소모성 제품 구매.** 앱에서 바로 구매 제품은 구매하고 사용한 다음 다시 구매할 수 있습니다. | 소모성 구매는 일반 구매를 만든 다음 **consumePurchase**를 통해 이를 소모할 수 있으며 구매, 사용, 다시 구매할 수 있습니다. | 소모성 제품은 iTunes Connect에서 **소모성 제품으로 정의**됩니다. | 스토어에 [제출할 때 제품 형식을 소모성으로 정의](https://msdn.microsoft.com/library/windows/apps/mt148534.aspx)하여 소모성 제품을 지원할 수 있습니다. 그런 다음 고객이 소모성 제품에 액세스할 수 있게 되면 **[CurrentApp.ReportConsumableFulfillmentAsync](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentapp.reportconsumablefulfillmentasync.aspx)**를 호출할 수 있습니다.<br/><br/>[앱에서 바로 소모성 제품 구매 사용](https://msdn.microsoft.com/library/windows/apps/mt219683.aspx) |
|  **앱에서 바로 구매 테스트.** 스토어에 앱을 추가하지 않고 앱에서 바로 구매 코드를 테스트할 수 있습니다. | **앱에서 바로 청구 샌드박스**가 테스트에 사용됩니다.  | **샌드박스 테스터 계정**이 테스트에 사용됩니다. | CurrentApp 대신 **[CurrentAppSimulator](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.currentappsimulator.aspx)** 클래스를 사용하여 간단히 앱에서 바로 구매를 테스트할 수 있습니다.<br/><br/> |
|  **무료 평가판.** 앱의 평가판을 기준으로 쉽게 콘텐츠를 제한하거나 광고를 제거할 수 있습니다. | Google Play는 **앱 평가판을 공식적으로 지원하지 않습니다**. 평가판 또는 광고 제거 버전을 얻으려면 앱에서 바로 구매를 만들고 구매를 완료했을 때 받은 적절한 코드 경로를 사용해야 합니다. | 앱 스토어는 **앱 평가판을 공식적으로 지원하지 않습니다**. 평가판 또는 광고 제거 버전을 얻으려면 앱에서 바로 구매를 만들고 구매를 완료했을 때 받은 적절한 코드 경로를 사용해야 합니다. | 스토어에 앱을 제출할 때 **['무료 평가판' 옵션](https://msdn.microsoft.com/library/windows/apps/mt148548.aspx)**을 사용하여 앱의 무료 평가판 버전을 제공할 수 있습니다. 그런 다음 **[LicenseInformation.IsTrial](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.licenseinformation.istrial.aspx)**을 사용하여 앱의 평가판 상태를 확인하고 그에 따라 다른 코드 경로를 제공합니다. 앱 실행 중 사용자가 평가판 상태를 변경할 때 알릴 [LicenseChanged 이벤트](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.store.licenseinformation.licensechanged)를 등록할 수 있습니다.<br/><br/>[평가판의 기능 제외 또는 제한](https://msdn.microsoft.com/library/windows/apps/mt219685.aspx) |

## 여러 플랫폼에 맞게 조정

|  **일반적인 개념** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **적응 UI: 유연한 레이아웃.** 유연한 높이 및 너비를 사용하여 다양한 화면 크기를 지원합니다. | 유연한 레이아웃을 사용하려면 LinearLayout 개체에서 **wrap_content** 및 **match_parent** 값을 사용하거나 맞춤을 위해 RelativeLayout을 사용합니다. | 유연한 레이아웃을 사용하려면 유니버설 스토리보드와 함께 **적응 모델**을 사용하여 컨트롤러를 볼 때 적용되는 horizontalSizeClass 및 displayScale 등의 **제약 조건** 및 **특성**과 함께 **자동 레이아웃**을 사용합니다. | 고정 및 동적 크기 조정의 조합과 함께 **레이아웃 속성** 및 **패널**을 사용하여 유동 레이아웃을 만들 수 있습니다.<br/><br/>[XAML을 사용하여 레이아웃 정의 - 레이아웃 속성 및 패널](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx#layout_overview)<br/><br/>[반응형 디자인 101](https://msdn.microsoft.com/library/windows/apps/dn958435.aspx) |
|  **적응 UI: 맞춤형 레이아웃.** 개별 대상의 레이아웃을 사용하여 다양한 화면 크기를 지원합니다. | **small**, **large**, **ldpi** 및 **hdpi**와 같은 **구성 한정자**를 사용하여 리소스 디렉터리의 다양한 화면 구성에 대해 대체 레이아웃 파일을 제공합니다. | **개별 iPhone 및 iPad 스토리보드**를 정의하여 유니버설 앱의 다른 디바이스 패밀리에 맞게 레이아웃을 조정합니다. | 디바이스 패밀리마다 **다른 XAML 태그 파일**을 정의하여 맞춤형 레이아웃을 빌드할 수 있습니다.<br/><br/>[XAML을 사용하여 레이아웃 정의 - 맞춤형 레이아웃](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx#tailored_layouts) |
|  **적응 UI: 반응형 레이아웃.** 회전 등의 화면 크기 변경 또는 창 크기 변경에 응답합니다. | **LinearLayout** 및 **RelativeLayout**을 통해 유연한 레이아웃을 사용하거나 다양한 방향을 위한 대체 레이아웃 파일을 제공하여 반응형 레이아웃을 설정합니다. | 뷰의 **크기** 또는 **특성**을 변경할 때 스토리보드에 지정된 **제약 조건**이 적용됩니다. | **
            [VisualState](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstate.aspx)**, **[VisualStateManager](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.visualstatemanager.aspx)** 및 **[AdaptiveTrigger](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.adaptivetrigger.aspx)**를 사용한 창 크기 변경에 대한 응답으로 런타임 시 UI에 대해 쉽게 재배치, 위치 변경, 크기 변경, 노출 또는 섹션 바꾸기 등을 수행할 수 있습니다.<br/><br/>[XAML을 사용하여 레이아웃 정의 - 시각적 상태 및 상태 트리거](https://msdn.microsoft.com/library/windows/apps/mt228350.aspx#visual_states_and_state_triggers)<br/><br/>[반응형 디자인 101](https://msdn.microsoft.com/library/windows/apps/dn958435.aspx) |
|  **다른 디바이스 기능 지원.** 고급 하드웨어 기능을 활용하고 이러한 기능이 없는 디바이스를 지원합니다. | 런타임 시 **PackageManager.hasSystemFeature**를 사용하여 디바이스 기능을 테스트하면 하드웨어 관련 코드 실행 가능 여부를 확인할 수 있습니다. | 런타임 시 디바이스 기능을 테스트하기 위해 수행할 수 있는 **단일 검사는 없으며** 특정 방법으로 각 기능을 테스트하여 하드웨어 관련 코드를 실행할 수 있는지 확인합니다. | **플랫폼 확장 SDK**를 패키지에 추가하여 휴대폰, 데스크톱, IoT 등 다른 디바이스 패밀리의 추가 기능을 대상으로 할 수 있습니다. **
            [ApiInformation API](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.aspx)**를 사용하여 런타임 시 형식과 멤버의 존재 여부를 테스트하고 있는 경우에만 이러한 형식 및 멤버를 호출할 수 있습니다. |
|  **다른 디바이스 기능 지원.** 고급 하드웨어 기능을 활용하고 이러한 기능이 없는 디바이스를 지원합니다. | **Android 지원 라이브러리**를 앱과 패키징하면 이전 버전의 Android 앱에서 일부 최신 API를 사용할 수 있습니다. 런타임 시 API 수준에 대한 테스트는 **Build.Version.SDK_INT**를 사용하여 수행할 수 있습니다. | 표준 런타임 검사는 API 사용 가능 여부를 확인하는 데 사용됩니다. 예를 들어 **class** 메서드는 클래스 존재 여부를 확인하고 **respondsToSelector:**는 클래스의 메서드를 확인합니다.  | **
            [ApiInformation.IsApiContractPresent](https://msdn.microsoft.com/library/windows/apps/dn949005.aspx)**를 사용하여 지정된 주 및 부 번호의 API 계약이 있는지 확인할 수 있습니다. 또한 **[ApiInformation API](https://msdn.microsoft.com/library/windows/apps/windows.foundation.metadata.apiinformation.aspx)**를 사용하여 런타임 시 형식과 멤버의 존재 여부를 테스트하고 있는 경우에만 이러한 형식 및 멤버를 호출할 수 있습니다. |

## 알림

|  **일반적인 개념** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **타일 및 배지.** 홈 화면에서 사용자에게 업데이트를 제공합니다. | **앱 위젯**은 홈 화면에 포함하여 정기 업데이트를 받을 수 있는 응용 프로그램의 보기입니다. Android에는 **배지 시스템이 없습니다**. 타일에 동일한 시스템이 없습니다. | iOS에는 **타임 또는 위젯이 없습니다**. 아이콘에 숫자와 함께 **배지**를 추가할 수 있으며 이는 로컬 또는 원격 알림에 대한 응답으로 변경될 수 있습니다. | 앱에는 시작 화면에 고정하여 선택한 텍스트를 표시할 수 있는 **타일**과, 숫자 및 문자 모양이 있는 **배지**가 있습니다. 푸시 알림 또는 미리 정의된 일정에 따라 앱에서 타일 콘텐츠를 업데이트할 수 있습니다. 타일은 적응형이 될 수 있으며 표시 중인 위치에 따라 변경될 수 있습니다.<br/><br/>[타일 만들기](https://msdn.microsoft.com/library/windows/apps/xaml/mt185605.aspx)<br/><br/>[적응형 타일 만들기](https://msdn.microsoft.com/library/windows/apps/xaml/mt590880.aspx)<br/><br/>[알림 전달 방법 선택](https://msdn.microsoft.com/library/windows/apps/xaml/mt187193.aspx)<br/><br/>[타일 및 배지에 대한 지침](https://msdn.microsoft.com/library/windows/apps/xaml/hh465403.aspx) |
|  **알림 표시.** 표시될 수 있는 알림 형식입니다. | 알림은 **알림 영역** 및 **알림 창**에 표시할 수 있으며 **경고 알림**은 작은 부동 창에 알림을 제공합니다. **PendingIntent**를 정의하여 알림에 작업을 추가할 수 있습니다. | 팝업 알림은 **배너** 또는 **경고**로 나타납니다. **UIMutableUserNotificationAction**을 사용하여 정의된 사용자 지정 작업 단추를 **실행 가능한 알림**에 추가할 수 있습니다. | **알림 메시지**라는 적응형 팝업 알림을 만들 수 있습니다. XML에서 시각적 콘텐츠, **작업** 단추 또는 입력 및 오디오가 있는 알림 메시지를 정의할 수 있습니다.<br/><br/>[적응형 및 대화형 알림 메시지](https://msdn.microsoft.com/library/windows/apps/xaml/mt631604.aspx)<br/><br/>[알림 전달 방법 선택](https://msdn.microsoft.com/library/windows/apps/xaml/mt187193.aspx)<br/><br/>[알림 메시지에 대한 지침](https://msdn.microsoft.com/library/windows/apps/xaml/hh465391.aspx) |
|  **로컬 알림 예약.** 예약된 시간에 앱에서 보낸 로컬 알림입니다. | 알림 및 작업은 **NotificationCompat.Builder**를 사용하여 정의되며 앱에서 **AlarmManager** 및 **BroadcastReceiver**를 사용하여 예약 및 처리할 수 있습니다. | 로컬 알림은 **UILocalNotification**을 사용하여 만들어지며 ** UILocalNotification.scheduleLocalNotification:**을 통해 예약할 수 있습니다. | **
            [ScheduledToastNotification](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.notifications.scheduledtoastnotification.aspx)**을 사용하여 알림 메시지를 예약할 수 있습니다. **
            [TileNotification 클래스](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.notifications.tilenotification.aspx)**를 사용하여 앱에서 타일 알림을 보내거나 [ScheduledTileNotification](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.notifications.scheduledtilenotification.aspx)을 사용하여 타일 알림을 예약할 수 있습니다.<br/><br/>[적응형 및 대화형 알림 메시지](https://msdn.microsoft.com/library/windows/apps/xaml/mt631604.aspx)<br/><br/>[로컬 타일 알림 보내기](https://msdn.microsoft.com/library/windows/apps/xaml/mt593299.aspx) |
|  **푸시 알림 보내기.** 푸시 알림 서버에서 보내고 필요에 따라 앱에서 처리되는 알림입니다. | **Google Cloud Messaging**에서는 Android용 푸시 알림 지원을 제공합니다. | **APNs(Apple Push Notification Service)**에서 원격 또는 푸시 알림이 제공됩니다. | **WNS(Windows 푸시 알림 서비스)**에서 보낸 타일, 알림, 배지 또는 원시 알림 형식의 푸시 알림을 수신할 수 있습니다. 앱이 실행 중인 동안 [PushNotificationReceived](https://msdn.microsoft.com/library/windows/apps/xaml/windows.networking.pushnotifications.pushnotificationchannel.pushnotificationreceived.aspx) 알림 전달 이벤트를 사용하여 알림을 받을 수 있습니다.<br/><br/>[WNS(Windows 푸시 알림 서비스) 개요](https://msdn.microsoft.com/library/windows/apps/xaml/mt187203.aspx)<br/><br/>[원시 알림 개요](https://msdn.microsoft.com/library/windows/apps/xaml/mt187200.aspx) |

## 미디어 캡처 및 렌더링

|  **일반적인 개념** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **미디어 캡처.** 오디오 및 동영상 콘텐츠를 기록합니다. | MediaStore.ACTION_VIDEO_CAPTURE 등의 **의도**를 사용하여 기존 카메라 앱으로 미디어를 캡처할 수 있습니다. **android.hardware.camera2** 또는 **카메라** 라이브러리를 사용하여 사용자 지정 카메라 인터페이스를 구현할 수 있습니다. **MediaRecorder** API를 사용하여 오디오를 캡처할 수 있습니다. | **UIImagePickerController**를 사용하면 시스템 UI로 동영상 및 사진을 캡처할 수 있습니다. **AVCaptureSession** 등의 **AVFoundation** 클래스를 사용하면 카메라에 직접 액세스할 수 있습니다. <br/>**AVAudioRecorder** 클래스를 사용하면 오디오를 녹음할 수 있습니다. | **
            [CameraCaptureUI 클래스](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.capture.cameracaptureui.aspx)**를 통해 기본 제공 카메라 UI를 사용하여 사진 및 동영상을 캡처할 수 있습니다. **
            [MediaCapture API](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.capture.mediacapture.aspx)** 등 **[Windows.Media.Capture](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.capture.aspx)**의 클래스를 사용하여 낮은 수준 카메라를 조작하고 오디오를 캡처할 수 있습니다. <br/><br/>[CameraCaptureUI를 사용하여 사진 및 비디오 캡처](https://msdn.microsoft.com/library/windows/apps/xaml/mt282142.aspx)<br/><br/>[MediaCapture를 사용하여 사진 및 비디오 캡처](https://msdn.microsoft.com/library/windows/apps/xaml/mt243896.aspx) |
|  **미디어 재생.** 오디오 및 동영상 파일을 재생합니다. | **MediaPlayer** 및 **AudioManager** 클래스는 오디오 및 동영상 파일을 재생하는 데 사용됩니다. | **AVKit 프레임워크**, **AVAudioPlayer** 및 **미디어 플레이어 프레임워크**는 오디오 및 동영상 파일을 재생하는 데 사용됩니다. | **
            [MediaSource 클래스](https://msdn.microsoft.com/library/windows/apps/xaml/windows.media.core.mediasource.aspx)**, **[MediaElement](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.mediaelement.aspx)** 및 **[MediaPlayer](https://msdn.microsoft.com/library/windows/apps/windows.media.playback.mediaplayer.aspx)** 클래스를 사용하여 로컬 및 원격 파일과 같은 원본에서 오디오 및 동영상을 재생할 수 있습니다.<br/><br/>[MediaSource를 사용하여 미디어 재생](https://msdn.microsoft.com/library/windows/apps/xaml/mt592657.aspx) |
|  **미디어 편집.** 기존 녹음에서 새 미디어 파일을 작성하고 특수 효과를 적용합니다. | **MediaCodec**, **MediaMuxer** 및 **android.media.effect**와 같은 낮은 수준 클래스를 콘텐츠 편집을 위해 사용할 수 있습니다. | 콘텐츠 편집을 위해 **AVMutableComposition**, **AVMutableVideoComposition** 및 **AVMutableAudioMix**와 같은 **AV Foundation** 프레임워크의 클래스를 사용할 수 있습니다. | **
            [MediaComposition](https://msdn.microsoft.com/library/windows/apps/windows.media.editing.mediacomposition.aspx)** 및 **[MediaClip](https://msdn.microsoft.com/library/windows/apps/windows.media.editing.mediaclip.aspx)**과 같은 **[Windows.Media.Editing](https://msdn.microsoft.com/library/windows/apps/windows.media.editing.aspx)** API를 사용하여 오디오 및 동영상 파일에서 미디어 컴퍼지션을 만들 수 있습니다. 동영상 및 이미지 오버레이 추가, 비디오 클립 결합, 백그라운드 오디오 추가, 오디오 및 동영상 효과를 적용할 수 있습니다.<br/><br/>[미디어 컴퍼지션 및 편집](https://msdn.microsoft.com/library/windows/apps/mt204792.aspx) |

## 센서

|  **일반적인 개념** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **센서.** 디바이스 이동, 위치 및 환경 속성을 검색합니다. | **센서 프레임워크**는 **SensorManager** 및 **SensorEvent** 등의 클래스를 사용하여 하드웨어 및 소프트웨어 센서에 액세스할 수 있습니다.  | **Core Motion 프레임워크**는 원시 및 처리된 센서 데이터에 액세스하는 데 사용됩니다. | **
            [Windows.Devices.Sensors](https://msdn.microsoft.com/library/windows/apps/windows.devices.sensors.aspx)**의 클래스를 사용하여 센서 읽기 및 센서에서 새 읽기 데이터가 수신될 때 트리거되는 이벤트에 액세스할 수 있습니다.<br/><br/>[센서](https://msdn.microsoft.com/library/windows/apps/xaml/mt187358.aspx) |

## 위치 및 매핑

|  **일반적인 개념** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **위치.** 디바이스의 **현재** 위치를 찾고 **변경 내용**을 추적합니다. | Google Play Services 위치 API는 **getLastLocation** 및 **requestLocationUpdates** 메서드를 사용하여 **퓨즈 위치 공급자**에게 **마지막으로 알려진 위치**에 대한 높은 수준 액세스를 제공합니다. **LocationManager**를 사용하여 Android 라이브러리에 낮은 수준 액세스를 제공합니다. | **핵심 위치****CLLocationManager** 클래스는 표준 위치 서비스에 대한 **startUpdatingLocation** 및 표준 위치 서비스 및 **중요한 변경** 위치 서비스에 대한 **startMonitoringSignificantLocationChanges**를 사용하여 디바이스의 위치를 모니터링하는 데 사용됩니다. | **
            [Windows.Devices.Geolocation](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.aspx)**의 클래스를 사용하여 디바이스 위치를 추적할 수 있습니다. 한 번 읽으려면 **[Geolocator.GetGeopositionAsync](https://msdn.microsoft.com/library/windows/apps/br225537.aspx)**를 사용합니다. **
            [Geolocator.PositionChanged](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geolocator.positionchanged.aspx)**를 사용하여 타이머를 통해 위치를 정기적으로 가져오거나 위치가 변경될 때 알림을 받을 수 있습니다.<br/><br/>[사용자 위치 가져오기](https://msdn.microsoft.com/library/windows/apps/mt219698.aspx) |
|  **지도 표시.** **대화형 기본 제공 지도**를 표시하고 **관심 지점**을 추가합니다. | **Google 지도 Android API**의 **GoogleMap**, **MapFragment** 및 **MapView** 클래스를 사용하여 지도를 앱에 포함할 수 있습니다. 관심 지점은 **표식** 및 사용자 지정 가능한 **Marker** 클래스를 사용하여 표시할 수 있습니다. | 지도는 **MapKit 프레임워크**의 **MKMapView** 클래스를 사용하여 iOS 앱에 포함됩니다. 앱에 **주석**을 추가하여 **MKPointAnnotation** 등의 개체 클래스와 **MKPinAnnotationView** 등의 보기 클래스를 통해 관심 지점을 표시할 수 있습니다. | 2D, 3D 및 Streetside 뷰를 제공하는 기본 제공 **[MapControl](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mapcontrol.aspx)** XAML 컨트롤을 사용하여 앱에 지도를 포함할 수 있습니다. **
            [MapIcon](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mapicon.aspx)**, **[MapPolygon](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mappolygon.aspx)** 및 **[MapPolyline](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.controls.maps.mappolyline.aspx)** 등의 클래스를 사용하여 고정핀, 이미지 또는 셰이프로 관심 지점을 추가할 수 있습니다.<br/><br/>[2D, 3D 및 Streetside 뷰가 있는 지도 표시](https://msdn.microsoft.com/library/windows/apps/mt219695.aspx)<br/><br/>[지도에 POI(관심 지점) 표시](https://msdn.microsoft.com/library/windows/apps/mt219696.aspx) |
|  **지오펜스.** 특정 지리적 지역에 들어가고 나가는 것을 모니터링합니다. | 지오펜스는 Google Play Services SDK의 **위치 서비스**를 사용하여 모니터링됩니다. | 지역은 **CLCircularRegion** 클래스를 사용하여 모니터링되고 **CLLocationManager.startMonitoringForRegion:**을 사용하여 등록됩니다. | **
            [Geofence](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geofencing.geofence.aspx)** 클래스를 사용하여 지오펜스를 만들고 지역에 들어가기와 나가기 등 **모니터링 상태**를 정의합니다. **
            [GeofenceMonitor 클래스](https://msdn.microsoft.com/library/windows/apps/windows.devices.geolocation.geofencing.geofencemonitor.aspx)**를 사용하여 포그라운드에서, **[LocationTrigger 백그라운드 클래스](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.background.locationtrigger.aspx)**를 사용하여 백그라운드에서 지오펜스 이벤트를 처리합니다.<br/><br/>[지오펜스 설정](https://msdn.microsoft.com/library/windows/apps/mt219702.aspx) |
|  **지오코딩 및 리버스 지오코딩.** 주소를 지리적 위치로 변환하고(지오코딩) 지리적 위치를 주소로 변환합니다(리버스 지오코딩).<br/> | **Geocoder** 클래스는 지오코딩 및 리버스 지오코딩에 사용됩니다. | **CLGeocoder** 클래스는 지오코딩에 사용됩니다. | **
            [Windows.Services.Maps](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.aspx)**의 **[MapLocationFinder 클래스](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maplocationfinder.aspx)**를 사용하여 지오코딩을 수행할 수 있습니다. 지오코딩에 **[FindLocationsAsync](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maplocationfinder.findlocationsasync.aspx)**, 리버스 지오코딩에 **[FindLocationsAtAsync](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maplocationfinder.findlocationsatasync.aspx)**를 사용합니다.<br/><br/>[지오코딩 및 리버스 지오코딩 수행](https://msdn.microsoft.com/library/windows/apps/mt219697.aspx) |
|  **경로 및 길 찾기.** 경로, 거리 및 두 지리적 위치 간의 길 찾기를 제공합니다. | Google에서는 SDK가 제공되지 않지만 Android에서 사용할 수 있는 웹 서비스인 **Google 지도 방향 API**를 제공합니다. | 지도 키트는 경로 및 길 찾기에 대한 정보를 가져올 수 있는 **MKDirections** API를 제공합니다. | **
            [Windows.Services.Maps](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.aspx)**의 **[MapRouteFinder](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maproutefinder.aspx)** 클래스를 사용하여 도보 또는 운전 경로를 요청할 수 있습니다. 경로는 MapControl에 쉽게 표시할 수 있는 **[MapRoute](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maproute.aspx)** 인스턴스로 반환됩니다. 길 찾기는 **[MapRouteManeuver](https://msdn.microsoft.com/library/windows/apps/windows.services.maps.maproutemaneuver.aspx)** 개체 내에 반환됩니다.<br/><br/>[지도에 경로 및 길 찾기 표시](https://msdn.microsoft.com/library/windows/apps/mt219701.aspx) |

## 앱 간 통신

|  **일반적인 개념** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **다른 앱 호출.** 다른 앱을 시작하고 필요에 따라 링크, 텍스트, 사진, 동영상 및 파일을 공유합니다. | **암시적 의도**는 **의도**에서 **작업** 및 선택적 데이터를 정의하고 **startActivityForResult**를 통해 호출하여 다른 앱을 실행하는 데 사용됩니다.<br/> | **앱 확장**은 앱 데이터에 대한 액세스를 다른 앱에 제공하는 데 사용할 수 있습니다. **URL 체계**를 사용하면 URL을 다른 앱에 전달할 수 있습니다. | **
            [Launcher.LaunchUriAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.launcher.launchuriasync.aspx)** 또는 **[Launcher.LaunchUriForResultsAsync](https://msdn.microsoft.com/library/windows/apps/windows.system.launcher.launchuriforresultsasync.aspx)**를 사용하여 URI에 등록된 다른 앱을 실행하여 결과를 실행하고 실행된 앱에서 데이터를 다시 가져올 수 있습니다. **
            [Launcher.LaunchFileAsync](https://msdn.microsoft.com/library/windows/apps/hh701471.aspx)**를 사용하여 다른 앱에서 처리하도록 파일을 전달할 수 있습니다.<br/><br/>**공유 계약**을 사용하여 앱 간에 데이터를 쉽게 공유할 수 있습니다.<br/><br/>[URI에 대한 기본 앱 실행](https://msdn.microsoft.com/library/windows/apps/mt228340.aspx)<br/><br/>[결과에 대한 앱 실행](https://msdn.microsoft.com/library/windows/apps/mt269386.aspx)<br/><br/>[파일에 대한 기본 앱 시작](https://msdn.microsoft.com/library/windows/apps/mt299102.aspx)<br/><br/>[데이터 공유](https://msdn.microsoft.com/library/windows/apps/xaml/mt243293.aspx) |
|  **앱에서 호출 허용.** 앱에서 다른 앱의 요청에 응답할 수 있습니다. | 앱은 **의도 필터**로 **의도 처리 활동**을 등록하여 다른 앱의 암시적 의도에 응답합니다. | **앱 확장**을 패키징하면 다른 앱과 데이터를 공유할 수 있습니다. Info.plist의 **CFBundleURLTypes** 키를 사용하여 앱에서 **사용자 지정 URL 체계**를 등록할 수 있습니다. | 패키지 매니페스트에 **[프로토콜](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.activation.activationkind.aspx#Protocol)**을 등록하고, **[Application.OnActivated](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.application.onactivated.aspx)** 이벤트 처리기를 업데이트하고, 선택적으로 결과를 반환하여 앱이 **URI 체계 이름**에 대한 기본 처리기가 되도록 등록할 수 있습니다. 마찬가지로 패키지 매니페스트에 선언을 추가하고, **[Application.OnFileActivated](https://msdn.microsoft.com/library/windows/apps/windows.ui.xaml.application.onfileactivated.aspx)** 이벤트를 처리하여 앱을 특정 파일 형식에 대한 기본 처리기가 되도록 등록할 수 있습니다.<br/><br/>매니페스트에 공유 대상으로 앱을 등록하고, **[Application.OnShareTargetActivated](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.application.onsharetargetactivated.aspx)** 이벤트를 처리하여 계약 요청 공유를 처리할 수 있습니다.<br/><br/>[결과에 대한 앱 실행](https://msdn.microsoft.com/library/windows/apps/mt269386.aspx)<br/><br/>[파일 활성화 처리](https://msdn.microsoft.com/library/windows/apps/mt269385.aspx)<br/><br/>[데이터 수신](https://msdn.microsoft.com/library/windows/apps/xaml/mt243292.aspx) |
|  **복사 및 붙여넣기.** 앱 간에 텍스트 및 기타 콘텐츠를 복사하고 붙여넣습니다. | **클립보드 프레임워크**를 사용하여 **ClipboardManager** 및 **ClipData** 클래스로 복사 및 붙여넣기를 구현할 수 있습니다. | **UIPasteboard**, **UIMenuController** 및 **UIResponderStandardEditActions**를 사용하여 복사 및 붙여넣기를 구현할 수 있습니다. | 많은 기본 XAML 컨트롤은 이미 복사 및 붙여넣기를 지원합니다. **
            [Windows.ApplicationModel.DataTransfer](https://msdn.microsoft.com/library/windows/apps/br205967)**의 **[DataPackage](https://msdn.microsoft.com/library/windows/apps/windows.applicationmodel.datatransfer.datapackage.aspx)** 및 **[Clipboard](https://msdn.microsoft.com/library/windows/apps/xaml/windows.applicationmodel.datatransfer.clipboard.aspx)** 클래스를 사용하여 복사 및 붙여넣기를 구현할 수 있습니다.<br/><br/>[복사 및 붙여넣기](https://msdn.microsoft.com/library/windows/apps/xaml/mt243291.aspx) |
|  **끌어서 놓기.** 앱 간에 콘텐츠를 끌어서 놓습니다. | 단일 응용 프로그램 내에서 **Android 끌기/놓기 프레임워크**를 사용하여 끌어서 놓기를 구현할 수 있습니다. | iOS에서는 높은 수준의 끌어서 놓기 API가 제공되지 않습니다. | 앱에서 끌어서 놓기를 구현하여 앱-앱, 데스크톱-앱, 앱-데스크톱 간 끌어서 놓기 기능을 구현할 수 있습니다. **
            [AllowDrop](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.allowdrop.aspx)** 및 **[CanDrag](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.candrag.aspx)** 속성, **[DragOver](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.dragover.aspx)** 및 **[Drop](https://msdn.microsoft.com/library/windows/apps/xaml/windows.ui.xaml.uielement.drop.aspx)** 이벤트를 사용하여 UIElement 클래스에서 끌어서 놓기 지원을 구현합니다.<br/><br/>[끌어서 놓기](https://msdn.microsoft.com/library/windows/apps/xaml/mt227651.aspx) |

## 소프트웨어 디자인

|  **일반적인 개념** | **Android** | **iOS** | **Windows 10** |
|  ------ | ------ | ------ | ------ |
|  **소프트웨어 디자인 패턴.** 플랫폼에 대해 권장되거나 사용에 적합한 패턴입니다. | 베타 데이터 바인딩 프레임워크는 **MVVM(Model-View-ViewModel)** 패턴을 더 광범위하게 사용할 수 있지만 Android 개발에 대해 권장되거나 제공되는 공식 패턴은 없습니다. 많은 타사 문서 및 프레임워크에서 **MVP(Model-View-Presenter)** 및 **MVVM** 접근 방식을 권장합니다. | **MVC(Model-View-Controller)**는 iOS와 함께 사용되고 플랫폼에 통합된 일반 패턴입니다. | UWP를 빌드할 때 특정 패턴으로 제한되지는 않습니다.<br/><br/>기본 제공 [데이터 바인딩](https://msdn.microsoft.com/library/windows/apps/mt210947.aspx) 패턴을 사용하여 데이터 관심사와 UI 관심사를 분리할 수 있으며 속성 값을 업데이트하는 UI 이벤트 처리기를 코딩할 필요가 없습니다.<br/><br/>[MVVM Light Toolkit](https://mvvmlight.codeplex.com/)와 같은 타사 MVVM 라이브러리를 사용하거나 고유 라이브러리를 롤링하거나 논리를 숨겨진 코드 밖에 유지함으로써 데이터 바인딩을 확장하여 **MVVM(Model-View-ViewModel)** 패턴을 따를 수 있습니다.<br/><br/>[MVVM 패턴](https://msdn.microsoft.com/library/hh848246.aspx)<br/><br/>[템플릿 10 Visual Studio 프로젝트 템플릿](https://github.com/Windows-XAML/Template10/wiki) |


<!--HONumber=Mar16_HO1-->


